<!DOCTYPE html>
<html>
  <meta charset="utf-8">
  <title>Paxos</title>
  <!-- <link href='http://fonts.googleapis.com/css?family=Parisienne|Oxygen+Mono|PT+Mono|Offside|Nova+Mono|Averia+Serif+Libre|Alex+Brush|Autour+One|Share+Tech+Mono|Merriweather|Maven+Pro|Raleway' rel='stylesheet' type='text/css'>-->
  <!-- todo: why doesn't fork me float?-->
  <link href="https://fonts.googleapis.com/css?family=Cutive+Mono|Sorts+Mill+Goudy|Mate|Oxygen+Mono|Offside|Raleway:400,700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy">
  <link rel="stylesheet" type="text/css" href="css/ascetic.css">
  <link rel="stylesheet" type="text/css" href="css/style.css">
</html>
<body><a href="https://github.com/bigeasy/paxos/"><img style="position: fixed; top: 0; left: 0; border: 0" src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
  <div class="container">
    <div class="unit welcome">
      <h1>Paxos</h1>
      <!-- todo: code font is too small for body text font-->
    </div>
    <div class="unit description markdown include" data-file="index.md"><p>A replayable, deterministic implemenation of Paxos.</p>
<p>Sketch of what to say.</p>
<ul>
<li>Reproducable events for unit testing, but still a true Paxos.</li>
<li>In-memory so that no disk writes are necessary.</li>
<li>Fast because it</li>
</ul>
<p>A consensus algorithm will maintain a log between multiple machines, and
consensus is reached when a majority of the machines agree on an entry in the
log. The log is eventually consistent, meaning that the participants will learn
about the values eventually, but they will always learn about events in the same
order, so you can use this log to implement synchronization.</p>
<p>Paxos Made Simple, Again</p>
<p>If you simply want to get Paxos running, use
<a href="https://bigeasy.github.io/compassion">Compassion</a>. It is an implementation of
an atomic log using Paxos. From there you build your replicated state machines
and what have you.</p>
<p>This is the implemenation of Paxos. It is less than TK lines of JavaScript code.</p>
<p>The main class of the Paxos library is the <code>Legislator</code>. This is an active
participant in the Paxos algorithm. (Should it be <code>Citizen</code>? Should it be just
Paxos?)</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
</code></pre>
<p>Nodes on <code>Legislator</code>.</p>
<p><code>Legislator.citzens</code> ~ An object used as a map of properties of the citizens
of the island.</p>
<p><code>Legislator.government</code> ~ The structure of the goverment with an array of
majority members, an array of minority members and an array of constituents.</p>
<p><code>Legislator.outbox()</code> ~ Returns the next outbound pulse.</p>
<p><code>Legislator.sent(TK)</code> ~ Reports the results of a pulse.</p>
<h2 id="notes">Notes</h2>
<p>We can add an integer counter to the nodes. Integer so that it is fast. It will
have to wrap. This makes for a size limit of 4,294,967,296. Limits are
disheartening, but visibility means that we&apos;ll be able to be aware of the limits
and set alarms before those limits are reached.</p>
<p>The limit is due to the fact that counter will wrap to keep it within 32-bits,
which is fast. We could benchmark comparisons with floats and integers and see
if we&apos;re willing to not care.</p>
<p>We introduce the concept of heft to Procession so that developers can assign
their own limits.</p>
<p>The counter wraps. Hence the limit. That is the limit of the queue&apos;s contents,
not the limit of the queue&apos;s lifetime traffic.</p>
<p>Synchronous iteration is done with a simple linked list iterator. Perhaps I
invite the users to iterate on their own with nodes. Then they can promote the
nodes to consumers.</p>
<p>Iterators can be manipulated directly. They can be promoted to consumers. They
are not tracked like consumers. Instead, we mark the nodes as <code>shifted</code> when
the last consumer shifts them. We assert that a node is not shifted when our
dear user upgrades a node to a consumer.</p>
<p>With this number we can have visibility, counting the maximum held in the queue.
We can also have optional search. Actually, both heft and search can be
implemented using a listener object that has a method for adding and removing
a node.</p>
</div>
  </div>
  <!-- todo: move into an edify plugin-->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-20388260-3', 'bigeasy.github.io');
    ga('send', 'pageview');
  </script>
</body>
<!-- vim: set ts=2 sw=2 nowrap:-->
