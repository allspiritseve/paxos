<!DOCTYPE html>

<html>
<head>
  <title>paxos.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>

      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">


                <a class="source" href="acceptor.js.html">
                  acceptor.js
                </a>


                <a class="source" href="completion.js.html">
                  completion.js
                </a>


                <a class="source" href="constituency.js.html">
                  constituency.js
                </a>


                <a class="source" href="government.js.html">
                  government.js
                </a>


                <a class="source" href="paxos.js.html">
                  paxos.js
                </a>


                <a class="source" href="proposer.js.html">
                  proposer.js
                </a>


                <a class="source" href="recorder.js.html">
                  recorder.js
                </a>


                <a class="source" href="replay.js.html">
                  replay.js
                </a>


                <a class="source" href="shaper.js.html">
                  shaper.js
                </a>


                <a class="source" href="writer.js.html">
                  writer.js
                </a>

            </div>
          </div>
        </li>
      </ul>

    <ul class="sections">

          <li id="title">
              <div class="annotation">
                  <h1>paxos.js</h1>
              </div>
          </li>



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Common utilities.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>)</pre></div></div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Return the first not null-like value.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> coalesce = <span class="hljs-built_in">require</span>(<span class="hljs-string">'extant'</span>)</pre></div></div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Ever increasing serial value with no maximum value.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Monotonic = <span class="hljs-built_in">require</span>(<span class="hljs-string">'monotonic'</span>).asString</pre></div></div>

        </li>


        <li id="section-4">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>A timer with named, cancelable events.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Scheduler = <span class="hljs-built_in">require</span>(<span class="hljs-string">'happenstance'</span>).Scheduler</pre></div></div>

        </li>


        <li id="section-5">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>An evented message queue used for the atomic log.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Procession = <span class="hljs-built_in">require</span>(<span class="hljs-string">'procession'</span>)
<span class="hljs-keyword">var</span> Window = <span class="hljs-built_in">require</span>(<span class="hljs-string">'procession/window'</span>)</pre></div></div>

        </li>


        <li id="section-6">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>A sorted index into the atomic log. TODO Must it be a tree?</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Indexer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'procession/indexer'</span>)</pre></div></div>

        </li>


        <li id="section-7">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Logging conduit.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'prolific.logger'</span>).createLogger(<span class="hljs-string">'paxos'</span>)</pre></div></div>

        </li>


        <li id="section-8">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>The participants in the Paxos strategy.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Proposer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./proposer'</span>)
<span class="hljs-keyword">var</span> Acceptor = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./acceptor'</span>)</pre></div></div>

        </li>


        <li id="section-9">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>The participants in the two-phase commit strategy.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Shaper = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./shaper'</span>)
<span class="hljs-keyword">var</span> Writer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./writer'</span>)
<span class="hljs-keyword">var</span> Recorder = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./recorder'</span>)

<span class="hljs-keyword">var</span> departure = <span class="hljs-built_in">require</span>(<span class="hljs-string">'departure'</span>)</pre></div></div>

        </li>


        <li id="section-10">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h3 id="constructor">Constructor</h3>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Paxos</span> (<span class="hljs-params">now, republic, id, options</span>) </span>{</pre></div></div>

        </li>


        <li id="section-11">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Uniquely identify ourselves relative to the other participants.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.id = <span class="hljs-built_in">String</span>(id)</pre></div></div>

        </li>


        <li id="section-12">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Use the create time as a cookie to identify this instance of this id.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.cookie = now</pre></div></div>

        </li>


        <li id="section-13">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>A republic identifies a particular instance of the Paxos algorithm.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.republic = republic</pre></div></div>

        </li>


        <li id="section-14">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Maximum size of a parliament. The government will grow to this size.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.parliamentSize = coalesce(options.parliamentSize, <span class="hljs-number">5</span>)</pre></div></div>

        </li>


        <li id="section-15">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>The atomic log is a linked list. When head of the list is advanced the
entries in the list become unreachable and can be collected by the
garbage collector. We advance the head of the list when we are certain
that all participants have received a copy of the entry and added it to
their logs. Outstanding user iterators prevent garbage collection.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.log = <span class="hljs-keyword">new</span> Window
    <span class="hljs-keyword">this</span>.log.addListener(<span class="hljs-keyword">this</span>.indexer = <span class="hljs-keyword">new</span> Indexer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">left, right</span>) </span>{
        assert(left &amp;&amp; right)
        assert(left.body &amp;&amp; right.body)
        <span class="hljs-keyword">return</span> Monotonic.compare(left.body.promise, right.body.promise)
    }))</pre></div></div>

        </li>


        <li id="section-16">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Implements a calendar for events that we can check during runtime or
ignore during debugging playback.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.scheduler = <span class="hljs-keyword">new</span> Scheduler</pre></div></div>

        </li>


        <li id="section-17">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Initial government. A null government.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.government = {
        <span class="hljs-attr">promise</span>: <span class="hljs-string">'0/0'</span>,
        <span class="hljs-attr">majority</span>: [],
        <span class="hljs-attr">minority</span>: [],
        <span class="hljs-attr">naturalized</span>: [],
        <span class="hljs-attr">constituents</span>: [],
        <span class="hljs-attr">properties</span>: {},
        <span class="hljs-attr">immigrated</span>: { <span class="hljs-attr">id</span>: {}, <span class="hljs-attr">promise</span>: {} }
    }</pre></div></div>

        </li>


        <li id="section-18">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Keep track of governments for bootstrapping.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._governments = [ <span class="hljs-literal">null</span> ]</pre></div></div>

        </li>


        <li id="section-19">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Last promise issued.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._promised = <span class="hljs-literal">null</span></pre></div></div>

        </li>


        <li id="section-20">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Ping is the frequency of keep alive pings.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.ping = coalesce(options.ping, <span class="hljs-number">1000</span>)</pre></div></div>

        </li>


        <li id="section-21">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Timeout when that reached marks a citizen for exile.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.timeout = coalesce(options.timeout, <span class="hljs-number">5000</span>)</pre></div></div>

        </li>


        <li id="section-22">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>The citizens that this citizen updates with new log entries.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.constituency = []</pre></div></div>

        </li>


        <li id="section-23">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Entire population.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.citizens = []</pre></div></div>

        </li>


        <li id="section-24">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Upper bound of the atomic log.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._committed = {}</pre></div></div>

        </li>


        <li id="section-25">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Propagated lower bound of the atomic log.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._minimum = { <span class="hljs-attr">propagated</span>: <span class="hljs-string">'0/0'</span>, <span class="hljs-attr">version</span>: <span class="hljs-string">'0/0'</span>, <span class="hljs-attr">reduced</span>: <span class="hljs-string">'0/0'</span> }
    <span class="hljs-keyword">this</span>._minimums = {}
    <span class="hljs-keyword">this</span>._minimums[<span class="hljs-keyword">this</span>.id] = <span class="hljs-keyword">this</span>._minimum

    <span class="hljs-keyword">this</span>._naturalizing = {}</pre></div></div>

        </li>


        <li id="section-26">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Network message queue.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.outbox = <span class="hljs-keyword">new</span> Procession</pre></div></div>

        </li>


        <li id="section-27">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Push the null government onto the atomic log.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.log.push({
        <span class="hljs-attr">module</span>: <span class="hljs-string">'paxos'</span>,
        <span class="hljs-attr">method</span>: <span class="hljs-string">'government'</span>,
        <span class="hljs-attr">promise</span>: <span class="hljs-string">'0/0'</span>,
        <span class="hljs-attr">body</span>: <span class="hljs-keyword">this</span>.government,
        <span class="hljs-attr">previous</span>: <span class="hljs-literal">null</span>
    })</pre></div></div>

        </li>


        <li id="section-28">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Write strategy is polymorphic, changes based on whether we’re recovering
from collapse using Paxos or writing values using two-phase commit.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._writer = <span class="hljs-keyword">new</span> Writer(<span class="hljs-keyword">this</span>, <span class="hljs-string">'1/0'</span>, [])
    <span class="hljs-keyword">this</span>._recorder = <span class="hljs-keyword">new</span> Recorder(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.log.head.body)</pre></div></div>

        </li>


        <li id="section-29">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Shaper a new government by fiat based on whose available to grow to the
desired government size and who is unreachable.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._shaper = <span class="hljs-keyword">new</span> Shaper(<span class="hljs-keyword">this</span>.parliamentSize, <span class="hljs-keyword">this</span>.government, <span class="hljs-literal">false</span>)</pre></div></div>

        </li>


        <li id="section-30">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Used for our pseudo-random number generator to vary retry times.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._seed = <span class="hljs-number">1</span></pre></div></div>

        </li>


        <li id="section-31">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Track unreachable citizens.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._disappeared = {}
    <span class="hljs-keyword">this</span>._unreachable = {}
}</pre></div></div>

        </li>


        <li id="section-32">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <h3 id="government">Government</h3>

            </div>

        </li>


        <li id="section-33">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Constructs a new government and unshifts it onto the head of the proposal
queue. During two-phase commit, new governments jump to the line. All the
user messages are given new promises whose values are greater than the value
of the government’s promise.</p>
<p>During a collapse when we are running Paxos, the new government is the only
message and all user messages are dropped.</p>
<p>There is only ever supposed to be one new government in process or in the
list of proposals. Many decisions about the new government are based on the
current government and the current health of the island, so queuing up a
bunch of governments would at the very least require that we double check
that they are still valid.</p>
<p>Basically, we have new governments queued elsewhere. Actually, we have
network status queued elsewhere and new governments are proposed after the
current new government is established based on that reachability data.</p>

            </div>

        </li>


        <li id="section-34">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype.newGovernment = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, promise, quorum, government</span>) </span>{
    assert(<span class="hljs-built_in">arguments</span>.length == <span class="hljs-number">4</span>)</pre></div></div>

        </li>


        <li id="section-35">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Mark the shaper as complete. We won’t get a new government proposal until
we get a new shaper.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._shaper.decided = <span class="hljs-literal">true</span>

    <span class="hljs-keyword">if</span> (government.exile != <span class="hljs-literal">null</span>) {
        government.exile = {
            <span class="hljs-attr">id</span>: government.exile,
            <span class="hljs-attr">promise</span>: <span class="hljs-keyword">this</span>.government.immigrated.promise[government.exile],
            <span class="hljs-attr">properties</span>: <span class="hljs-keyword">this</span>.government.properties[government.exile],
            <span class="hljs-attr">index</span>: {}
        }
        <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>.government.constituents.indexOf(government.exile.id)
        <span class="hljs-keyword">if</span> (~index) {
            government.exile.index.constituents = index
        }
        index = <span class="hljs-keyword">this</span>.government.naturalized.indexOf(government.exile.id)
        <span class="hljs-keyword">if</span> (~index) {
            government.exile.index.naturalized = index
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (government.promote != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, id; (id = government.promote[i]) != <span class="hljs-literal">null</span>; i++) {
            government.promote[i] = { <span class="hljs-attr">id</span>: id, <span class="hljs-attr">index</span>: <span class="hljs-keyword">this</span>.government.constituents.indexOf(id) }
        }
        government.promote.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">left, right</span>) </span>{ <span class="hljs-keyword">return</span> right.index - left.index })
    }</pre></div></div>

        </li>


        <li id="section-36">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>If we are doing a two-phase commit, remap the proposals so that they have
a promise value in the new government.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> remapped = government.promise = promise, map = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._writer.collapsed) {
        map = {}
        <span class="hljs-keyword">this</span>._writer.proposals = <span class="hljs-keyword">this</span>._writer.proposals.splice(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>._writer.proposals.length).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">proposal</span>) </span>{
            proposal.was = proposal.promise
            proposal.route = government.majority
            proposal.promise = remapped = Monotonic.increment(remapped, <span class="hljs-number">1</span>)
            map[proposal.was] = proposal.promise
            <span class="hljs-keyword">return</span> proposal
        })
    }
    <span class="hljs-keyword">this</span>._promised = remapped

    government.map = map

    assert(<span class="hljs-keyword">this</span>._writer.proposals.length == <span class="hljs-number">0</span> || !Monotonic.isBoundary(<span class="hljs-keyword">this</span>._writer.proposals[<span class="hljs-number">0</span>].promise, <span class="hljs-number">0</span>))

    <span class="hljs-keyword">this</span>._writer.unshift({ <span class="hljs-attr">promise</span>: promise, <span class="hljs-attr">quorum</span>: quorum, <span class="hljs-attr">body</span>: government })
    <span class="hljs-keyword">this</span>._writer.nudge()
}</pre></div></div>

        </li>


        <li id="section-37">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <h3 id="bootstrap">Bootstrap</h3>

            </div>

        </li>


        <li id="section-38">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Initialize the citizen with a government where it is the dictator.</p>

            </div>

        </li>


        <li id="section-39">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype.bootstrap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, properties</span>) </span>{
    <span class="hljs-keyword">var</span> government = {
        <span class="hljs-attr">promise</span>: <span class="hljs-string">'1/0'</span>,
        <span class="hljs-attr">majority</span>: [],
        <span class="hljs-attr">minority</span>: [],
        <span class="hljs-attr">naturalize</span>: <span class="hljs-keyword">this</span>.id,
        <span class="hljs-attr">constituents</span>: [],
        <span class="hljs-attr">map</span>: {},
        <span class="hljs-attr">immigrate</span>: { <span class="hljs-attr">id</span>: <span class="hljs-keyword">this</span>.id, <span class="hljs-attr">properties</span>: properties, <span class="hljs-attr">cookie</span>: <span class="hljs-number">0</span> },
        <span class="hljs-attr">properties</span>: {},
        <span class="hljs-attr">immigrated</span>: { <span class="hljs-attr">promise</span>: {}, <span class="hljs-attr">id</span>: {} }
    }

    government.properties[<span class="hljs-keyword">this</span>.id] = properties
    government.immigrated.promise[<span class="hljs-keyword">this</span>.id] = <span class="hljs-string">'1/0'</span>
    government.immigrated.id[<span class="hljs-string">'1/0'</span>] = <span class="hljs-keyword">this</span>.id

    <span class="hljs-keyword">this</span>._promised = <span class="hljs-string">'1/0'</span>

    <span class="hljs-keyword">this</span>._shaper.immigrate({ <span class="hljs-attr">id</span>: <span class="hljs-keyword">this</span>.id, <span class="hljs-attr">cookie</span>: <span class="hljs-number">0</span> })

    <span class="hljs-keyword">this</span>._commit(now, { <span class="hljs-attr">promise</span>: <span class="hljs-string">'1/0'</span>, <span class="hljs-attr">body</span>: government, <span class="hljs-attr">previous</span>: <span class="hljs-string">'0/0'</span> }, <span class="hljs-string">'0/0'</span>)
}</pre></div></div>

        </li>


        <li id="section-40">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <h3 id="enqueue-and-immigrate">Enqueue and Immigrate</h3>

            </div>

        </li>


        <li id="section-41">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>TODO Is all this checking necessary? Is it necessary to return the island id
and leader? This imagines that the client is going to do the retry, but in
reality we often have the cluster perform the retry. The client needs to talk
to a server that can be discovered, it can’t use the Paxos algorithm for
address resolution. From the suggested logic, it will only have a single
address, and maybe be told of an actual leader. What happens when that
address is lost? Don’t see where returning <code>republic</code> and leader helps at
all. It is enough to say you failed, back-off and try again. The network
layer can perform checks to see if the recipient is the leader and hop to the
actual leader if it isn’t, reject if it is but collapsed.</p>
<p>Once you’ve externalized this in kibitz, remove it, or pare it down.</p>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype._enqueuable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">republic</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._writer.collapsed || <span class="hljs-keyword">this</span>.republic != republic) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">enqueued</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">republic</span>: <span class="hljs-keyword">this</span>.republic,
            <span class="hljs-attr">leader</span>: <span class="hljs-literal">null</span>
        }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>] != <span class="hljs-keyword">this</span>.id) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">enqueued</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">republic</span>: <span class="hljs-keyword">this</span>.republic,
            <span class="hljs-attr">leader</span>: <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>]
        }
    }
}</pre></div></div>

        </li>


        <li id="section-42">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Note that a client will have to treat a network failure on submission as a
failure requiring boundary detection.</p>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, republic, message</span>) </span>{
    <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">this</span>._enqueuable(republic)
    <span class="hljs-keyword">if</span> (response == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">this</span>._promised = Monotonic.increment(<span class="hljs-keyword">this</span>._promised, <span class="hljs-number">1</span>)
        <span class="hljs-keyword">this</span>._writer.push({
            <span class="hljs-attr">promise</span>: promise,
            <span class="hljs-attr">quorum</span>: <span class="hljs-keyword">this</span>.government.majority,
            <span class="hljs-attr">body</span>: message
        })
        <span class="hljs-keyword">this</span>._writer.nudge()

        response = {
            <span class="hljs-attr">enqueued</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">leader</span>: <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>],
            <span class="hljs-attr">promise</span>: promise
        }
    }
    <span class="hljs-keyword">return</span> response
}</pre></div></div>

        </li>


        <li id="section-43">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>TODO This is a note. I’d like to find a place to journal this. I’m continuing
to take measures to allow for the reuse of ids. It still feels right to me
that a display of government or of the census would be displayed using values
meaningful to our dear user; Kubernetes HOSTNAMES, AWS instance names, IP
address, and not something that is guaranteed unique like a UUID, because
such things are indistinguishable to the human observer.</p>
<p>Yet, here I am again contending with an issue that would be so simple if ids
where required to be unique. When a citizen that is a constituent dies and
restarts with the same id it will be pinged by someone in government, it will
report that it’s empty, and its representative will look for it’s immigration
record. There’s a race now. Is the new instance going to immigrate before its
pinged? Or is the representative going to search for an immigration record
and not find one, which causes us to abend at the moment?</p>
<p>When we get a sync before immigration, it will not see a cookie or not see
the right cookie and fail the sync. These syncs fail, time passes, the time
out comes and the record is cleared. That takes care of the race when the
sync beats the immigration record, but what if the immigration record beats
the representative?</p>
<p>In that case their will be a new government with the same representative with
the same constituent, but now there will be an immigration record. The
constituent will be naturalized. It will never have been exiled.</p>
<p>This is a problem. Implementations are going to need to know that they’ve
restarted. A participant should be exiled before it can immigrate again.</p>
<p>Obviously, much easier if the ids are unique. Whole new id means not
ambiguity. The new id immigrates, the old id exiles. (Unique ids are easy
enough to foist upon our dear user implementation wise. Most implementations
reset a process or at least an object, and that new instance can have a new
id generated from POSIX time or UUID.)</p>
<p>However, we do have an atomic log at our disposal, so every time I think that
I should give up and go with unique ids, something comes along to make it
simple. I was actually musing about how the client, if they really wanted
pretty ids, they could just check and wait for the old id to exile, since it
only needs to be unique in the set of current ids. Then, duh, I can do that
same check on immigration and reject the immigration if the id already exists
in the census.</p>
<p>That’s what you’re looking at here.</p>
<p>Now that that is done, though, is there a race condition where the
immigration is currently being proposed? The property wouldn’t be removed
until the proposal was enacted.</p>

            </div>

        </li>


        <li id="section-44">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype.immigrate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, republic, id, cookie, properties, naturalized</span>) </span>{
    <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">this</span>._enqueuable(republic)
    <span class="hljs-keyword">if</span> (response == <span class="hljs-literal">null</span>) {</pre></div></div>

        </li>


        <li id="section-45">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Do not allow the user to initiate the immigration of an id that
already exists. This will happen if a denizen crash restarts and
tries to rejoin before Paxos can determine that the denizen is no
longer viable. The immigrating denizen should enter a back off and
retry loop in order to wait for exile.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (id <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.government.properties) {
            response = {
                <span class="hljs-attr">enqueued</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">republic</span>: <span class="hljs-keyword">this</span>.republic,
                <span class="hljs-attr">leader</span>: <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>]
            }
        } <span class="hljs-keyword">else</span> {
            response = { <span class="hljs-attr">enqueued</span>: <span class="hljs-literal">true</span> }
            <span class="hljs-keyword">this</span>._reshape(now, <span class="hljs-keyword">this</span>._shaper.immigrate({ <span class="hljs-attr">id</span>: id, <span class="hljs-attr">properties</span>: properties, <span class="hljs-attr">cookie</span>: cookie, <span class="hljs-attr">naturalized</span>: naturalized }))
        }
    }
    <span class="hljs-keyword">return</span> response
}

Paxos.prototype.naturalize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (!~<span class="hljs-keyword">this</span>.government.naturalized.indexOf(<span class="hljs-keyword">this</span>.id)) {
        <span class="hljs-keyword">this</span>._naturalizing[<span class="hljs-keyword">this</span>.government.immigrated.promise[<span class="hljs-keyword">this</span>.id]] = <span class="hljs-literal">true</span>
    }
}</pre></div></div>

        </li>


        <li id="section-46">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <h3 id="scheduled-events">Scheduled Events</h3>

            </div>

        </li>


        <li id="section-47">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Timer-driven events are managed using <a href="http://github.com/bigeasy/happenstance">Happenstance</a>.
Events are scheduled by calling the <code>schedule</code> method of a Happenstance
the <code>Schedule</code> object for this citizen. Each event has a key and scheduling
an event will replace an scheduled event with the same key, making it easy to
reset timeouts, to basically reset countdowns or replace the countdown action
as the role of the citizen changes.</p>

            </div>

        </li>


        <li id="section-48">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype.event = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">envelope</span>) </span>{</pre></div></div>

        </li>


        <li id="section-49">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Other envelope times are related to timer maintenance.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (envelope.module != <span class="hljs-string">'happenstance'</span> || envelope.method != <span class="hljs-string">'event'</span>) {
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">var</span> now = envelope.now
    <span class="hljs-keyword">switch</span> (envelope.body.method) {</pre></div></div>

        </li>


        <li id="section-50">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Send a synchronization message to one or more fellow citizens. Note that
the to field is an array.</p>

            </div>

        </li>


        <li id="section-51">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">case</span> <span class="hljs-string">'synchronize'</span>:
        <span class="hljs-keyword">this</span>._send({
            <span class="hljs-attr">method</span>: <span class="hljs-string">'synchronize'</span>,
            <span class="hljs-attr">to</span>: envelope.body.to,
            <span class="hljs-attr">collapsible</span>: !! envelope.body.collapsible,
            <span class="hljs-attr">constituent</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">key</span>: envelope.key
        })
        <span class="hljs-keyword">break</span></pre></div></div>

        </li>


        <li id="section-52">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>We are a majority member that has not heard from the leader for longer
than the timeout so collapse the current government. This turns our
<code>Writer</code> into a <code>Proposer</code> and starts running Paxos.</p>

            </div>

        </li>


        <li id="section-53">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">case</span> <span class="hljs-string">'collapse'</span>:
        <span class="hljs-keyword">this</span>._collapse(now)
        <span class="hljs-keyword">break</span></pre></div></div>

        </li>


        <li id="section-54">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Prepare a round of Paxos. We pick from the legislators that have not
disappeared. If a majority of legislators have disappeared, we reset our
disappeared map and try anyway because what else are we going to do? Note
that we ignore the unreachable map during a collapse.</p>
<p>TODO Collapse means Paxos. Put that in the documentation somewhere.</p>

            </div>

        </li>


        <li id="section-55">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">case</span> <span class="hljs-string">'propose'</span>:
        <span class="hljs-keyword">for</span> (;;) {</pre></div></div>

        </li>


        <li id="section-56">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>If we win, we are the leader.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> majority = [ <span class="hljs-keyword">this</span>.id ]
            <span class="hljs-keyword">var</span> minority = []</pre></div></div>

        </li>


        <li id="section-57">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Try to find a majority of legislators.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> parliament = <span class="hljs-keyword">this</span>.government.majority.concat(<span class="hljs-keyword">this</span>.government.minority)
            <span class="hljs-keyword">while</span> (parliament.length != <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">var</span> id = parliament.shift()
                <span class="hljs-keyword">if</span> (id != <span class="hljs-keyword">this</span>.id) {
                    <span class="hljs-keyword">if</span> (
                        majority.length == <span class="hljs-keyword">this</span>.government.majority.length ||
                        <span class="hljs-keyword">this</span>._disappeared[<span class="hljs-keyword">this</span>.government.immigrated.promise[id]] != <span class="hljs-literal">null</span>
                    ) {
                        minority.push(id)
                    } <span class="hljs-keyword">else</span> {
                        majority.push(id)
                    }
                }
            }</pre></div></div>

        </li>


        <li id="section-58">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>If we have a majority of legislators, we have have run a
forming this government with ourselves as leader.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (majority.length == <span class="hljs-keyword">this</span>.government.majority.length) {
                <span class="hljs-keyword">this</span>.newGovernment(now, <span class="hljs-keyword">this</span>._writer.promise, majority, { <span class="hljs-attr">majority</span>: majority, <span class="hljs-attr">minority</span>: minority })
                <span class="hljs-keyword">break</span>
            }</pre></div></div>

        </li>


        <li id="section-59">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>If we don’t have enough reachable participants for a majority,
clear out our disappearance tracking in a desperate move.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">this</span>._disappeared = {}
        }
        <span class="hljs-keyword">break</span>
    }
}</pre></div></div>

        </li>


        <li id="section-60">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <h3 id="collapse">Collapse</h3>

            </div>

        </li>


        <li id="section-61">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>Called by a recorder when a prepare method is received to transition from a
two-phase commit recorder to a Paxos acceptor.</p>

            </div>

        </li>


        <li id="section-62">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype._prepare = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, request, sync</span>) </span>{</pre></div></div>

        </li>


        <li id="section-63">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>TODO Always, really? Let the acceptor decide when to replace itself.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._recorder = <span class="hljs-keyword">new</span> Acceptor(<span class="hljs-keyword">this</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._recorder.request(now, request, sync)
}</pre></div></div>

        </li>


        <li id="section-64">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Collapse means we schedule a round of Paxos.</p>

            </div>

        </li>


        <li id="section-65">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype._collapse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now</span>) </span>{
    <span class="hljs-keyword">this</span>.scheduler.clear()</pre></div></div>

        </li>


        <li id="section-66">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>TODO Really need to have the value for previous, which is the writer register.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._writer = <span class="hljs-keyword">new</span> Proposer(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.government.promise)
    <span class="hljs-keyword">this</span>._propose(now, <span class="hljs-literal">false</span>)
}</pre></div></div>

        </li>


        <li id="section-67">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Note that even if the PNRG where not deterministic, it wouldn’t matter during
replay because the delay is lost and the actual timer event is recorded.</p>

            </div>

        </li>


        <li id="section-68">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>TODO Convince yourself that the above is true and the come back and replace
this PRNG with <code>Math.rand()</code>. TODO Meh.</p>

            </div>

        </li>


        <li id="section-69">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>TODO Consider how to back off. If the leader is gone and two majority members
are competing, do we really want them backing off for approaching “timeout”
milliseconds? How fast does it take to complete a round of Paxos and how big
of a window do we want to give two or more citizens to launch their retries
such that they avoid collision?</p>

            </div>

        </li>


        <li id="section-70">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype._propose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, retry</span>) </span>{
    <span class="hljs-keyword">var</span> delay = <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> (retry) {
        delay += <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.id != <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>]) {
            delay += <span class="hljs-keyword">this</span>.ping
        }</pre></div></div>

        </li>


        <li id="section-71">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>PRNG: <a href="https://gist.github.com/blixt/f17b47c62508be59987b">https://gist.github.com/blixt/f17b47c62508be59987b</a></p>

            </div>

            <div class="content"><div class='highlight'><pre>        delay += (<span class="hljs-keyword">this</span>._seed = <span class="hljs-keyword">this</span>._seed * <span class="hljs-number">16807</span> % <span class="hljs-number">2147483647</span>) % <span class="hljs-keyword">this</span>.ping
    }
    <span class="hljs-keyword">this</span>.scheduler.schedule(now + delay, <span class="hljs-keyword">this</span>.id, { <span class="hljs-attr">method</span>: <span class="hljs-string">'propose'</span>, <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span> })
}</pre></div></div>

        </li>


        <li id="section-72">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <h3 id="requests-and-responses">Requests and Responses</h3>

            </div>

        </li>


        <li id="section-73">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>Find a round of paxos in the log based on the given promise.</p>
<p>Not loving how deeply nested these conditions and keys are, but I understand
why it is that way, and it would be a full wrapper of <code>bintrees</code> to fix it.</p>

            </div>

        </li>


        <li id="section-74">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype._findRound = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sought</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.indexer.tree.find({ <span class="hljs-attr">body</span>: { <span class="hljs-attr">promise</span>: sought } })
}

Paxos.prototype._sync = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">committed</span>) </span>{
    <span class="hljs-keyword">var</span> sync = {
        <span class="hljs-attr">republic</span>: <span class="hljs-keyword">this</span>.republic,
        <span class="hljs-attr">promise</span>: <span class="hljs-keyword">this</span>.government.immigrated.promise[<span class="hljs-keyword">this</span>.id],
        <span class="hljs-attr">from</span>: <span class="hljs-keyword">this</span>.id,
        <span class="hljs-attr">minimum</span>: <span class="hljs-keyword">this</span>._minimum,
        <span class="hljs-attr">government</span>: <span class="hljs-keyword">this</span>.government.promise,
        <span class="hljs-attr">collapsed</span>: <span class="hljs-keyword">this</span>._writer.collapsed,
        <span class="hljs-attr">committed</span>: <span class="hljs-keyword">this</span>.log.head.body.promise,
        <span class="hljs-attr">commits</span>: []
    }
    <span class="hljs-keyword">if</span> (committed == <span class="hljs-literal">null</span>) {
        sync.synced = <span class="hljs-literal">false</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> iterator

        assert(Monotonic.compare(committed, <span class="hljs-keyword">this</span>._minimum.propagated) &gt;= <span class="hljs-number">0</span>, <span class="hljs-string">'minimum breached'</span>)
        assert(Monotonic.compare(committed, <span class="hljs-keyword">this</span>.log.head.body.promise) &lt;= <span class="hljs-number">0</span>, <span class="hljs-string">'maximum breached'</span>)
        iterator = <span class="hljs-keyword">this</span>._findRound(committed).next

        <span class="hljs-keyword">var</span> count = <span class="hljs-number">24</span>
        <span class="hljs-keyword">while</span> (--count &amp;&amp; iterator != <span class="hljs-literal">null</span>) {
            sync.commits.push({
                <span class="hljs-attr">promise</span>: iterator.body.promise,
                <span class="hljs-attr">body</span>: iterator.body.body,
                <span class="hljs-attr">previous</span>: iterator.body.previous
            })
            iterator = iterator.next
        }

        sync.synced =
            sync.commits.length == <span class="hljs-number">0</span> ||
            sync.commits[sync.commits.length - <span class="hljs-number">1</span>].promise == <span class="hljs-keyword">this</span>.log.head.body.promise
    }
    <span class="hljs-keyword">return</span> sync
}</pre></div></div>

        </li>


        <li id="section-75">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Package a message with log synchronization messages and put it in our outbox
for delivery to the intended fellow citizens.</p>
<p>Note that messages can take however long they’re going to take. They requests
can always be received and the responses can always be handled. If they are
made invalid by their time in transit they will be rejected. Our dear user
needs only to send the messages to our fellow citizens by any means and
return the responses to us all at once.</p>

            </div>

        </li>


        <li id="section-76">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype._send = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>{
    <span class="hljs-keyword">var</span> envelopes = [], responses = {}, syncs = {}, synchronize = <span class="hljs-literal">false</span>, government = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">var</span> cookie = {
        <span class="hljs-attr">message</span>: message,
        <span class="hljs-attr">synchronize</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">government</span>: <span class="hljs-keyword">this</span>.government.promise,
        <span class="hljs-attr">collapsed</span>: <span class="hljs-keyword">this</span>._writer.collapsed
    }
    TO: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, to; (to = message.to[i]) != <span class="hljs-literal">null</span>; i++) {
        <span class="hljs-keyword">this</span>.scheduler.unschedule(to)

        <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">this</span>.government.immigrated.promise[to]
        <span class="hljs-keyword">var</span> committed = coalesce(<span class="hljs-keyword">this</span>._committed[promise])

        <span class="hljs-keyword">if</span> (committed == <span class="hljs-string">'0/0'</span>) {
            <span class="hljs-keyword">var</span> immigrations = []
            <span class="hljs-keyword">var</span> iterator = <span class="hljs-keyword">this</span>.log.trailer.node.next, previous
            <span class="hljs-keyword">for</span> (;;) {
                <span class="hljs-keyword">if</span> (iterator == <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">break</span>
                }
                <span class="hljs-keyword">if</span> (Monotonic.isBoundary(iterator.body.promise, <span class="hljs-number">0</span>)) {
                    <span class="hljs-keyword">var</span> immigrate = iterator.body.body.immigrate
                    <span class="hljs-keyword">if</span> (immigrate &amp;&amp; immigrate.id == to) {
                        immigrations.push(iterator)
                    }
                }
                previous = iterator
                iterator = iterator.next
            }

            <span class="hljs-keyword">if</span> (immigrations.length == <span class="hljs-number">0</span>) {
                responses[to] = <span class="hljs-literal">null</span>
                <span class="hljs-keyword">continue</span> TO
            }

            <span class="hljs-keyword">var</span> immigration = immigrations.pop()
            committed = immigration.body.previous

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>, J = <span class="hljs-keyword">this</span>._governments.length; j &lt; J; j++) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._governments[j].promise == immigration.body.promise) {
                    government = <span class="hljs-keyword">this</span>._governments[j - <span class="hljs-number">1</span>]
                    <span class="hljs-keyword">break</span>
                }
            }
        }

        syncs[to] = <span class="hljs-keyword">this</span>._sync(committed)
        cookie.synchronize = cookie.synchronize || ! syncs[to].synced
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, to; (to = message.to[i]) != <span class="hljs-literal">null</span>; i++) {
        <span class="hljs-keyword">if</span> (syncs[to] == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">continue</span>
        }

        envelopes.push({
            <span class="hljs-attr">from</span>: <span class="hljs-keyword">this</span>.id,
            <span class="hljs-attr">to</span>: to,
            <span class="hljs-attr">properties</span>: <span class="hljs-keyword">this</span>.government.properties[to],
            <span class="hljs-attr">cookie</span>: cookie,
            <span class="hljs-attr">request</span>: {
                <span class="hljs-attr">message</span>: message,
                <span class="hljs-attr">government</span>: government,
                <span class="hljs-attr">synchronize</span>: cookie.synchronize || message.method == <span class="hljs-string">'synchronize'</span>,
                <span class="hljs-attr">sync</span>: syncs[to]
            },
            <span class="hljs-attr">responses</span>: responses
        })
    }</pre></div></div>

        </li>


        <li id="section-77">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Structured so that you can invoke <code>_response</code> using either an individual
envelope or the entire send structure.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.outbox.push({
        <span class="hljs-attr">from</span>: <span class="hljs-keyword">this</span>.id,
        <span class="hljs-attr">properties</span>: <span class="hljs-keyword">this</span>.government.properties[<span class="hljs-keyword">this</span>.id],
        <span class="hljs-attr">cookie</span>: cookie,
        <span class="hljs-attr">responses</span>: responses,
        <span class="hljs-attr">envelopes</span>: envelopes
    })
}</pre></div></div>

        </li>


        <li id="section-78">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>TODO Note that minimum only ever goes up so a delayed minimum is not going to
ever be invalid. We don’t want to run it in case it rejects our start.</p>

            </div>

        </li>


        <li id="section-79">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype.request = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, request</span>) </span>{
    <span class="hljs-keyword">if</span> (request.sync.republic != <span class="hljs-keyword">this</span>.republic) {
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">message</span>: { <span class="hljs-attr">method</span>: <span class="hljs-string">'unreachable'</span> } }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (
        <span class="hljs-keyword">this</span>.government.immigrated.promise[request.sync.from] != request.sync.promise
    ) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.promise == <span class="hljs-string">'0/0'</span>) {
            <span class="hljs-keyword">if</span> (request.sync.commits.length == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">message</span>: { <span class="hljs-attr">method</span>: <span class="hljs-string">'respond'</span>, <span class="hljs-attr">promise</span>: <span class="hljs-string">'0/0'</span> },
                    <span class="hljs-attr">sync</span>: <span class="hljs-keyword">this</span>._sync(<span class="hljs-literal">null</span>),
                    <span class="hljs-attr">government</span>: <span class="hljs-literal">null</span>
                }
            }
            <span class="hljs-keyword">if</span> (
                !Monotonic.isBoundary(request.sync.commits[<span class="hljs-number">0</span>].promise, <span class="hljs-number">0</span>) ||
                request.sync.commits[<span class="hljs-number">0</span>].body.immigrate == <span class="hljs-literal">null</span> ||
                request.sync.commits[<span class="hljs-number">0</span>].body.immigrate.id != <span class="hljs-keyword">this</span>.id ||
                request.sync.commits[<span class="hljs-number">0</span>].body.immigrate.cookie != <span class="hljs-keyword">this</span>.cookie
            ) {
                <span class="hljs-keyword">return</span> { <span class="hljs-attr">message</span>: { <span class="hljs-attr">method</span>: <span class="hljs-string">'unreachable'</span> } }
            }
            <span class="hljs-keyword">this</span>.government = request.government
            <span class="hljs-keyword">this</span>._commit(now, request.sync.commits[<span class="hljs-number">0</span>], request.sync.commits[<span class="hljs-number">0</span>].previous)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">message</span>: { <span class="hljs-attr">method</span>: <span class="hljs-string">'unreachable'</span> } }
        }
    }

    <span class="hljs-keyword">if</span> (Monotonic.compare(<span class="hljs-keyword">this</span>._minimum.propagated, request.sync.minimum.propagated) &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">this</span>._minimum.propagated = request.sync.minimum.propagated
    }

    <span class="hljs-keyword">var</span> message, committed = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">if</span> (
        Monotonic.compare(request.sync.committed, <span class="hljs-keyword">this</span>.log.head.body.promise) &lt; <span class="hljs-number">0</span>
    ) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">message</span>: {
                <span class="hljs-attr">method</span>: <span class="hljs-string">'reject'</span>,
                <span class="hljs-attr">promise</span>: <span class="hljs-keyword">this</span>.log.head.body.promise,
            },
            <span class="hljs-attr">government</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">sync</span>: {
                <span class="hljs-attr">promise</span>: <span class="hljs-keyword">this</span>.government.immigrated.promise[<span class="hljs-keyword">this</span>.id],
                <span class="hljs-attr">committed</span>: <span class="hljs-literal">null</span>,
                <span class="hljs-attr">commits</span>: []
            },
            <span class="hljs-attr">backwards</span>: <span class="hljs-literal">true</span>
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>._synchronize(now, request.sync.commits)

        <span class="hljs-keyword">while</span> (Monotonic.compare(<span class="hljs-keyword">this</span>.log.trailer.peek().promise, <span class="hljs-keyword">this</span>._minimum.propagated) &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">var</span> entry = <span class="hljs-keyword">this</span>.log.trailer.shift()
            <span class="hljs-keyword">if</span> (entry.government != <span class="hljs-literal">null</span>) {
                assert(entry.promise == <span class="hljs-keyword">this</span>._governments[<span class="hljs-number">1</span>].promise, <span class="hljs-string">'wrong government at shift time'</span>)
                <span class="hljs-keyword">this</span>._governments.shift()
            }
        }

        <span class="hljs-keyword">if</span> (
            ~<span class="hljs-keyword">this</span>.government.majority.slice(<span class="hljs-number">1</span>).indexOf(<span class="hljs-keyword">this</span>.id) &amp;&amp;
            ! <span class="hljs-keyword">this</span>._writer.collapsed
        ) {
            <span class="hljs-keyword">this</span>.scheduler.schedule(now + <span class="hljs-keyword">this</span>.timeout, <span class="hljs-keyword">this</span>.id, {
                <span class="hljs-attr">module</span>: <span class="hljs-string">'paxos'</span>,
                <span class="hljs-attr">method</span>: <span class="hljs-string">'collapse'</span>,
                <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span>
            })
        }

        message = request.synchronize
                ? { <span class="hljs-attr">method</span>: <span class="hljs-string">'synchronized'</span>, <span class="hljs-attr">promise</span>: <span class="hljs-keyword">this</span>.log.head.body.promise }
                : <span class="hljs-keyword">this</span>._recorder.request(now, request.message)
    }
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: message,
        <span class="hljs-attr">sync</span>: <span class="hljs-keyword">this</span>._sync(committed),
        <span class="hljs-attr">government</span>: <span class="hljs-keyword">this</span>.government.promise,
        <span class="hljs-attr">minimum</span>: <span class="hljs-keyword">this</span>._minimum,
        <span class="hljs-attr">naturalizing</span>: <span class="hljs-keyword">this</span>._naturalizing,
        <span class="hljs-attr">unreachable</span>: <span class="hljs-keyword">this</span>._unreachable
    }
}

Paxos.prototype.response = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, cookie, responses</span>) </span>{</pre></div></div>

        </li>


        <li id="section-80">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>We only process messages if the government that generated them is the
same as our current government. This is so that promises match ids
correctly, so that we’re not processing an old message with out of date
id to promise mappings or missing mappings. We make an exception for a
successful network connection, which we use to delete a disappeared flag.</p>

            </div>

        </li>


        <li id="section-81">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> message = cookie.message
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, I = message.to.length; i &lt; I; i++) {</pre></div></div>

        </li>


        <li id="section-82">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>Deduce recipient properties.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> id = message.to[i]
        <span class="hljs-keyword">var</span> response = responses[id]
        <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">this</span>.government.immigrated.promise[id]</pre></div></div>

        </li>


        <li id="section-83">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>If the citizen is unreachable we create a dummy record that uses our
current government for the government promise and a bunch of
defaults so that it will pass through the logic.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (
            response == <span class="hljs-literal">null</span> ||
            response.message.method == <span class="hljs-string">'unreachable'</span> ||
            !
            (
                promise == response.sync.promise ||
                <span class="hljs-string">'0/0'</span> == response.sync.committed
            )
        ) {
            responses[id] = response = {
                <span class="hljs-attr">message</span>: { <span class="hljs-attr">method</span>: <span class="hljs-string">'unreachable'</span>, <span class="hljs-attr">promise</span>: <span class="hljs-string">'0/0'</span> },
                <span class="hljs-attr">sync</span>: { <span class="hljs-attr">committed</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">commits</span>: [] },
                <span class="hljs-attr">minimum</span>: <span class="hljs-literal">null</span>,
                <span class="hljs-attr">unreachable</span>: {},
                <span class="hljs-attr">government</span>: <span class="hljs-keyword">this</span>.government.promise
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._disappeared[coalesce(promise, <span class="hljs-string">'0/0'</span>)]
        }
    }</pre></div></div>

        </li>


        <li id="section-84">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>TODO Why was it important that we keep pinging constituents while we are
negotiating a new government? Because it’s not happening now.
We stop if we’ve received a new government since this message has been
sent.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (
        cookie.government != <span class="hljs-keyword">this</span>.government.promise ||
        cookie.collapsed != <span class="hljs-keyword">this</span>._writer.collapsed
    ) {
        <span class="hljs-keyword">return</span>
    }

    <span class="hljs-keyword">var</span> collapsible = <span class="hljs-literal">false</span></pre></div></div>

        </li>


        <li id="section-85">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>Perform housekeeping for each recipient of the message.</p>

            </div>

        </li>


        <li id="section-86">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, I = message.to.length; i &lt; I; i++) {</pre></div></div>

        </li>


        <li id="section-87">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>Deduce recipient properties.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> id = message.to[i]
        <span class="hljs-keyword">var</span> response = responses[id]
        <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">this</span>.government.immigrated.promise[id]</pre></div></div>

        </li>


        <li id="section-88">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Go through responses converting network errors to “unreachable”
messages with appropriate defaults.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">switch</span> (response.message.method) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'unreachable'</span>:
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._disappeared[promise] == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">this</span>._disappeared[promise] = now
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (now - <span class="hljs-keyword">this</span>._disappeared[promise] &gt;= <span class="hljs-keyword">this</span>.timeout) {
                response.unreachable[promise] = <span class="hljs-literal">true</span>
            }
        <span class="hljs-keyword">case</span> <span class="hljs-string">'reject'</span>:
            collapsible = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">break</span>
        }</pre></div></div>

        </li>


        <li id="section-89">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>If we are out of date, then update our log. Otherwise, record the
recipient’s most committed message. Do not record the recipient’s
most committed message if it is ahead of us.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (response.sync.committed != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">this</span>._committed[promise] = response.sync.committed
        }</pre></div></div>

        </li>


        <li id="section-90">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>TODO Make a note to yourself somewhere, probably in tests, that if
you do want to deal with tricksy messages then testing is simple. At
this point, you’re trying to winnow down conditions by breaking up
operations and guarding them on pre-conditions. The one on your mind
now is that if you want to do something that requires translating a
promise to an id or vice-versa, then you’re going to need to have the
government that was active when that promise or id was posited.</p>

            </div>

        </li>


        <li id="section-91">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>You’ll forget this but, when you do add checks to validate the
structure of a message you will test it by calling these methods
directly. Testing that sort of thing would be simple. First, though,
you want to create the happy path and see that it is covered. Then
you have to deicide if you want to protect against malicious messages
or if you’re going to assume that you’re on an secure network.</p>

            </div>

        </li>


        <li id="section-92">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>The following operations assume that the citizen we’re talking too is
operating under the same government as ourselves. We want promise or
id look ups to not return null.</p>

            </div>

        </li>


        <li id="section-93">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-94">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>If the message was generated using government information that does
not match our current government, do not use it to update our
housekeeping state.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.promise != response.government) {
            <span class="hljs-keyword">continue</span>
        }</pre></div></div>

        </li>


        <li id="section-95">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>Update set of unreachable citizens.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> unreachable <span class="hljs-keyword">in</span> response.unreachable) {
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._unreachable[unreachable]) {
                <span class="hljs-keyword">this</span>._unreachable[unreachable] = <span class="hljs-literal">true</span>
                <span class="hljs-keyword">this</span>._reshape(now, <span class="hljs-keyword">this</span>._shaper.unreachable(unreachable))
            }
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> naturalizing <span class="hljs-keyword">in</span> response.naturalizing) {
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._naturalizing[naturalizing]) {
                <span class="hljs-keyword">this</span>._naturalizing[naturalizing] = <span class="hljs-literal">true</span>
                <span class="hljs-keyword">this</span>._reshape(now, <span class="hljs-keyword">this</span>._shaper.naturalize(naturalizing))
            }
        }</pre></div></div>

        </li>


        <li id="section-96">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>Reduce our least committed promise. Would switch to using promises as
the key in the minimum map, but out of date minimum records are never
able to do any damage. They will get updated eventually.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> minimum = response.minimum
        <span class="hljs-keyword">if</span> (
            message.constituent &amp;&amp;
            minimum &amp;&amp;
            (
                <span class="hljs-keyword">this</span>._minimums[id] == <span class="hljs-literal">null</span> ||
                <span class="hljs-keyword">this</span>._minimums[id].version != minimum.version ||
                <span class="hljs-keyword">this</span>._minimums[id].reduced != minimum.reduced
            )
        ) {
            <span class="hljs-keyword">this</span>._minimums[id] = {
                <span class="hljs-attr">version</span>: minimum.version,
                <span class="hljs-attr">propagated</span>: minimum.propagated,
                <span class="hljs-attr">reduced</span>: minimum.reduced
            }

            <span class="hljs-keyword">var</span> reduced = <span class="hljs-keyword">this</span>.log.head.body.promise

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>, constituent; (constituent = <span class="hljs-keyword">this</span>.constituency[j]) != <span class="hljs-literal">null</span>; j++) {
                <span class="hljs-keyword">if</span> (
                    <span class="hljs-keyword">this</span>._minimums[constituent] == <span class="hljs-literal">null</span> ||
                    <span class="hljs-keyword">this</span>._minimums[constituent].version != <span class="hljs-keyword">this</span>.government.promise ||
                    <span class="hljs-keyword">this</span>._minimums[constituent].reduced == <span class="hljs-string">'0/0'</span>
                ) {
                    reduced = <span class="hljs-string">'0/0'</span>
                    <span class="hljs-keyword">break</span>
                }
                <span class="hljs-keyword">if</span> (Monotonic.compare(<span class="hljs-keyword">this</span>._minimums[constituent].reduced, reduced) &lt; <span class="hljs-number">0</span>) {
                    reduced = <span class="hljs-keyword">this</span>._minimums[constituent].reduced
                }
            }

            <span class="hljs-keyword">this</span>._minimum = {
                <span class="hljs-attr">propagated</span>: <span class="hljs-keyword">this</span>.id == <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>] ? reduced : <span class="hljs-keyword">this</span>._minimum.propagated,
                <span class="hljs-attr">version</span>: <span class="hljs-keyword">this</span>.government.promise,
                <span class="hljs-attr">reduced</span>: reduced
            }
        }
    }

    <span class="hljs-keyword">if</span> (collapsible &amp;&amp; message.collapsible) {
        <span class="hljs-keyword">this</span>._writer.collapse(now, message, responses)
    }

    <span class="hljs-keyword">if</span> (
        !(
            cookie.government == <span class="hljs-keyword">this</span>.government.promise &amp;&amp;
            cookie.collapsed == <span class="hljs-keyword">this</span>._writer.collapsed
        )
    ) {
        <span class="hljs-keyword">return</span>
    }</pre></div></div>

        </li>


        <li id="section-97">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>Here’s were I’m using messages to drive the algorithm even when the
information is available for recalcuation.</p>
<p>There are two types of explicit synchronize. The leader will sync its log
with its majority, other members of the government will sync with their
constituents. With a majority sync, the leader will sync with all of the
majority members at once, any one of them failing triggers a collapse.</p>
<p>Consistent synchronize messages are sent to each constituent
individually.</p>
<p>TODO This is new.</p>

            </div>

        </li>


        <li id="section-98">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>Pings keep on going. When you start one it will perpetuate until the
government is superseded. If you want to synchronize before a ping,
simply schedule the ping immediately. If there is an outstanding ping
when you jump the gun, that’s fine. Pings are pretty much always valid.
Won’t this duplicate mean you now have two ping intervals? No. The
duplicate messaging will be reduced when the next ping gets scheduled
because you can only have one scheduled per key.</p>

            </div>

        </li>


        <li id="section-99">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (message.method == <span class="hljs-string">'synchronize'</span>) {</pre></div></div>

        </li>


        <li id="section-100">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>How long to wait before our next ping.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> delay = <span class="hljs-number">0</span></pre></div></div>

        </li>


        <li id="section-101">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>Use the ping interval if the citizen is unreachable or if it is
already up to date.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (
            collapsible ||
            <span class="hljs-keyword">this</span>.log.head.body.promise == responses[message.to[<span class="hljs-number">0</span>]].sync.committed
        ) {
            delay = <span class="hljs-keyword">this</span>.ping
        }</pre></div></div>

        </li>


        <li id="section-102">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>TODO Come back and consider this so you know that it is true.</p>

            </div>

        </li>


        <li id="section-103">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>Synchronizations live for the life of a government. We are not going
to double up or otherwise accumulate pings. They will be created by
with the promise of the government registered by the commit. If there
is a change of government the response won’t get beyond the first
exit of this function.</p>

            </div>

        </li>


        <li id="section-104">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>A keep alive might collapse the government, but it would then take
the last exit of this function before rescheduling itself.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>.scheduler.schedule(now + delay, message.key, {
            <span class="hljs-attr">method</span>: <span class="hljs-string">'synchronize'</span>, <span class="hljs-attr">to</span>: message.to, <span class="hljs-attr">collapsible</span>: message.collapsible
        })
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collapsible) {
        <span class="hljs-keyword">if</span> (cookie.synchronize) {
            <span class="hljs-keyword">this</span>._send(cookie.message)
        } <span class="hljs-keyword">else</span> {</pre></div></div>

        </li>


        <li id="section-105">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>TODO I don’t like how the <code>Recorder</code> gets skipped on collapse,
but the <code>Acceptor</code> handles it’s own failures. My fastidiousness
tells my that this one bit of reject logic escaping to another
function in another file is an indication of poor design and that
a design pattern is required to make this architecturally sound.
However, the bit that is escaping is the only bit that will be
dealing with inspecting returned promises and deciding a specific
next action, it is Paxos logic that does not otherwise exist, it
might actually be an additional layer.</p>

            </div>

        </li>


        <li id="section-106">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">this</span>._writer.response(now, message, responses)
        }
    }
}</pre></div></div>

        </li>


        <li id="section-107">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <h3 id="commit">Commit</h3>

            </div>

            <div class="content"><div class='highlight'><pre>
Paxos.prototype._register = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, register</span>) </span>{
    <span class="hljs-keyword">var</span> entries = []
    <span class="hljs-keyword">while</span> (register) {
        entries.push(register.body)
        register = register.previous
    }

    entries.reverse()

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, entry; (entry = entries[i]) != <span class="hljs-literal">null</span>; i++) {
        <span class="hljs-keyword">this</span>._commit(now, entry, <span class="hljs-keyword">this</span>.log.head.body.promise)
    }
}

Paxos.prototype._synchronize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, entries</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, entry; (entry = entries[i]) != <span class="hljs-literal">null</span>; i++) {
        <span class="hljs-keyword">this</span>._commit(now, entry, <span class="hljs-keyword">this</span>.log.head.body.promise)
    }
}

Paxos.prototype._reshape = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, shape</span>) </span>{
    <span class="hljs-keyword">if</span> (shape != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> promise = Monotonic.increment(<span class="hljs-keyword">this</span>.government.promise, <span class="hljs-number">0</span>)
        <span class="hljs-keyword">this</span>.newGovernment(now, promise, shape.quorum, shape.government)
    }
}

Paxos.prototype._commit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, entry, top</span>) </span>{
    entry = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(entry))

    logger.info(<span class="hljs-string">'_receiveEnact'</span>, { <span class="hljs-attr">now</span>: now, <span class="hljs-attr">$entry</span>: entry })</pre></div></div>

        </li>


        <li id="section-108">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>We already have this entry. The value is invariant, so let’s assert
that the given value matches the one we have.</p>

            </div>

        </li>


        <li id="section-109">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (Monotonic.compare(entry.promise, top) &lt;= <span class="hljs-number">0</span>) {
        departure.raise(<span class="hljs-keyword">this</span>._findRound(entry.promise).body.body, entry.body)
        <span class="hljs-keyword">return</span>
    }</pre></div></div>

        </li>


        <li id="section-110">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>Otherwise, we assert that entry has a correct previous promise.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    assert(top == entry.previous, <span class="hljs-string">'incorrect previous'</span>)

    <span class="hljs-keyword">var</span> isGovernment = Monotonic.isBoundary(entry.promise, <span class="hljs-number">0</span>)
    assert(isGovernment || Monotonic.increment(top, <span class="hljs-number">1</span>) == entry.promise)
    logger.info(<span class="hljs-string">'enact'</span>, { <span class="hljs-attr">isGovernment</span>: isGovernment, <span class="hljs-attr">$entry</span>: entry })

    <span class="hljs-keyword">var</span> government = <span class="hljs-literal">null</span>

    <span class="hljs-keyword">if</span> (isGovernment) {
        assert(Monotonic.compare(<span class="hljs-keyword">this</span>.government.promise, entry.promise) &lt; <span class="hljs-number">0</span>, <span class="hljs-string">'governments out of order'</span>)
        <span class="hljs-keyword">this</span>.government.promise = entry.promise
        <span class="hljs-keyword">this</span>.government.majority = entry.body.majority
        <span class="hljs-keyword">this</span>.government.minority = entry.body.minority
        <span class="hljs-keyword">if</span> (entry.body.immigrate != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (entry.promise == <span class="hljs-string">'1/0'</span>) {
                <span class="hljs-keyword">this</span>.government.majority.push(entry.body.immigrate.id)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>.government.constituents.push(entry.body.immigrate.id)
            }
            <span class="hljs-keyword">this</span>.government.immigrated.id[<span class="hljs-keyword">this</span>.government.immigrated.promise[entry.body.immigrate.id]]
            <span class="hljs-keyword">this</span>.government.immigrated.promise[entry.body.immigrate.id] = entry.promise
            <span class="hljs-keyword">this</span>.government.immigrated.id[entry.promise] = entry.body.immigrate.id
            <span class="hljs-keyword">this</span>.government.properties[entry.body.immigrate.id] = entry.body.immigrate.properties
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.body.exile != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.government.immigrated.id[<span class="hljs-keyword">this</span>.government.immigrated.promise[entry.body.exile.id]]
            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.government.immigrated.promise[entry.body.exile.id]
            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.government.properties[entry.body.exile.id]
            <span class="hljs-keyword">if</span> (<span class="hljs-string">'constituents'</span> <span class="hljs-keyword">in</span> entry.body.exile.index) {
                <span class="hljs-keyword">this</span>.government.constituents.splice(entry.body.exile.index.constituents, <span class="hljs-number">1</span>)
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-string">'naturalized'</span> <span class="hljs-keyword">in</span> entry.body.exile.index) {
                <span class="hljs-keyword">this</span>.government.naturalized.splice(entry.body.exile.index.naturalized, <span class="hljs-number">1</span>)
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.body.promote != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, promotion; (promotion = entry.body.promote[i]) != <span class="hljs-literal">null</span>; i++) {
                <span class="hljs-keyword">this</span>.government.constituents.splice(promotion.index, <span class="hljs-number">1</span>)
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.body.demote != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">this</span>.government.constituents.unshift(entry.body.demote)
        }
        <span class="hljs-keyword">if</span> (entry.body.naturalize != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">this</span>.government.naturalized.push(entry.body.naturalize)
        }

        <span class="hljs-keyword">var</span> parliament = <span class="hljs-keyword">this</span>.government.majority.concat(<span class="hljs-keyword">this</span>.government.minority), index
        <span class="hljs-keyword">if</span> (parliament.length == <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.id == <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>]) {
                <span class="hljs-keyword">this</span>.constituency = <span class="hljs-keyword">this</span>.government.constituents
                <span class="hljs-keyword">this</span>.representative = <span class="hljs-literal">null</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>.constituency = []
                <span class="hljs-keyword">this</span>.representative = <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>]
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>] == <span class="hljs-keyword">this</span>.id) {
            <span class="hljs-keyword">this</span>.constituency = <span class="hljs-keyword">this</span>.government.majority.slice(<span class="hljs-number">1</span>)
            <span class="hljs-keyword">this</span>.representative = <span class="hljs-literal">null</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> majority = <span class="hljs-keyword">this</span>.government.majority.slice(<span class="hljs-number">1</span>)
            <span class="hljs-keyword">var</span> index = majority.indexOf(<span class="hljs-keyword">this</span>.id)
            <span class="hljs-keyword">if</span> (~index) {
                <span class="hljs-keyword">var</span> length = majority.length
                <span class="hljs-keyword">var</span> population = <span class="hljs-keyword">this</span>.government.minority.length == <span class="hljs-number">0</span> ? <span class="hljs-keyword">this</span>.government.constituents : <span class="hljs-keyword">this</span>.government.minority
                <span class="hljs-keyword">this</span>.constituency = population.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, i</span>) </span>{ <span class="hljs-keyword">return</span> i % length == index })
                <span class="hljs-keyword">this</span>.representative = <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>]
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (~(index = <span class="hljs-keyword">this</span>.government.minority.indexOf(<span class="hljs-keyword">this</span>.id))) {
                <span class="hljs-keyword">var</span> length = <span class="hljs-keyword">this</span>.government.minority.length
                <span class="hljs-keyword">this</span>.constituency = <span class="hljs-keyword">this</span>.government.constituents.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, i</span>) </span>{
                    <span class="hljs-keyword">return</span> i % length == index
                })
                <span class="hljs-keyword">var</span> length = majority.length
                <span class="hljs-keyword">this</span>.representative = <span class="hljs-keyword">this</span>.government.majority.slice(<span class="hljs-number">1</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, i</span>) </span>{
                    <span class="hljs-keyword">return</span> index % length == i
                }).shift()
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>.government.constituents.indexOf(<span class="hljs-keyword">this</span>.id)
                <span class="hljs-keyword">var</span> representatives = <span class="hljs-keyword">this</span>.government.minority.length == <span class="hljs-number">0</span> ? majority : <span class="hljs-keyword">this</span>.government.minority
                <span class="hljs-keyword">var</span> length = representatives.length
                <span class="hljs-keyword">this</span>.constituency = []
                <span class="hljs-keyword">this</span>.representative = representatives.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, i</span>) </span>{
                    <span class="hljs-keyword">return</span> index % length == i
                }).shift()
            }
        }

        <span class="hljs-keyword">this</span>.citizens = <span class="hljs-keyword">this</span>.government.majority
                            .concat(<span class="hljs-keyword">this</span>.government.minority)
                            .concat(<span class="hljs-keyword">this</span>.government.constituents)

        government = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>.government))
        <span class="hljs-keyword">this</span>._governments.push(government)
    }

    <span class="hljs-keyword">this</span>.log.push({
        <span class="hljs-attr">module</span>: <span class="hljs-string">'paxos'</span>,
        <span class="hljs-attr">government</span>: government,
        <span class="hljs-attr">method</span>: isGovernment ? <span class="hljs-string">'government'</span> : <span class="hljs-string">'entry'</span>,
        <span class="hljs-attr">promise</span>: entry.promise,
        <span class="hljs-attr">body</span>: entry.body,
        <span class="hljs-attr">previous</span>: entry.previous
    })

    <span class="hljs-keyword">if</span> (isGovernment) {
        <span class="hljs-keyword">this</span>.scheduler.clear()</pre></div></div>

        </li>


        <li id="section-111">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>If we collapsed and ran Paxos we would have carried on regardless of
reachability until we made progress. During Paxos we ignore
reachability so we delete it here in case we happened to make
progress in spite of it.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (entry.body.map == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, id; (id = <span class="hljs-keyword">this</span>.government.majority[i]) != <span class="hljs-literal">null</span>; i++) {</pre></div></div>

        </li>


        <li id="section-112">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>TODO Probably okay to track by id. The worst that you can do
is delete reachable information that exists for a subsequent
version, well, the worse you can do is get rid of information
that will once again materialize.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._unreachable[<span class="hljs-keyword">this</span>.government.immigrated.promise[id]]
                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._disappeared[<span class="hljs-keyword">this</span>.government.immigrated.promise[id]]
            }
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, id; (id = <span class="hljs-keyword">this</span>.government.minority[i]) != <span class="hljs-literal">null</span>; i++) {
                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._unreachable[<span class="hljs-keyword">this</span>.government.immigrated.promise[id]]
                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._disappeared[<span class="hljs-keyword">this</span>.government.immigrated.promise[id]]
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> unreachable <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>._unreachable) {
                <span class="hljs-keyword">if</span> (!(unreachable <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.government.immigrated.id)) {
                    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._unreachable[unreachable]
                    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._disappeared[unreachable]
                }
            }
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> naturalizing <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>._naturalizing) {
            <span class="hljs-keyword">var</span> id = <span class="hljs-keyword">this</span>.government.immigrated.id[naturalizing]
            <span class="hljs-keyword">if</span> (!~<span class="hljs-keyword">this</span>.citizens.indexOf(id) || ~<span class="hljs-keyword">this</span>.government.naturalized.indexOf(id)) {
                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._naturalizing[naturalizing]
            }
        }

        <span class="hljs-keyword">this</span>._writer = <span class="hljs-keyword">this</span>._writer.createWriter(entry.promise)
        <span class="hljs-keyword">this</span>._recorder = <span class="hljs-keyword">this</span>._recorder.createRecorder(entry.promise)</pre></div></div>

        </li>


        <li id="section-113">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>Chose a strategy for handling pings.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.id == <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>]) {</pre></div></div>

        </li>


        <li id="section-114">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>If we are the leader, we are going to want to look for
opportunities to change the shape of the government.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> shaper = <span class="hljs-keyword">new</span> Shaper(<span class="hljs-keyword">this</span>.parliamentSize, <span class="hljs-keyword">this</span>.government, entry.body.map == <span class="hljs-literal">null</span>)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, immigration; (immigration = <span class="hljs-keyword">this</span>._shaper._immigrating[i]) != <span class="hljs-literal">null</span>; i++) {
                shaper.immigrate(immigration)
            }
            <span class="hljs-keyword">this</span>._shaper = shaper
            <span class="hljs-keyword">if</span> (entry.body.immigrate) {
                shaper.immigrated(entry.body.immigrate.id)
            }
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> promise <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>._unreachable) {
                <span class="hljs-keyword">this</span>._reshape(now, shaper.unreachable(promise))
            }
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> promise <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>._naturalizing) {
                <span class="hljs-keyword">this</span>._reshape(now, shaper.naturalize(promise))
            }
            <span class="hljs-keyword">this</span>.government.naturalized.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
                <span class="hljs-keyword">this</span>._reshape(now, shaper.naturalized(id))
            }, <span class="hljs-keyword">this</span>)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>._shaper = Shaper.null
        }

        <span class="hljs-keyword">if</span> (~<span class="hljs-keyword">this</span>.government.majority.indexOf(<span class="hljs-keyword">this</span>.id)) {
            <span class="hljs-keyword">this</span>.scheduler.schedule(now + <span class="hljs-keyword">this</span>.timeout, <span class="hljs-keyword">this</span>.id, {
                <span class="hljs-attr">module</span>: <span class="hljs-string">'paxos'</span>,
                <span class="hljs-attr">method</span>: <span class="hljs-string">'collapse'</span>,
                <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span>
            })
        }</pre></div></div>

        </li>


        <li id="section-115">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>You cannot keep a cached value for a constituent because new
governments will change that constituents constituents. The reduced
value must be recalculated.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._minimum = {
            <span class="hljs-attr">version</span>: <span class="hljs-keyword">this</span>.government.promise,
            <span class="hljs-attr">propagated</span>: <span class="hljs-keyword">this</span>._minimum.propagated,
            <span class="hljs-attr">reduced</span>: <span class="hljs-string">'0/0'</span>
        }
        <span class="hljs-keyword">this</span>._minimums = {}

        <span class="hljs-keyword">var</span> committed = {}
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, id; (id = <span class="hljs-keyword">this</span>.constituency[i]) != <span class="hljs-literal">null</span>; i++) {
            <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">this</span>.government.immigrated.promise[id]
            committed[promise] = <span class="hljs-keyword">this</span>._committed[promise]
        }
        <span class="hljs-keyword">this</span>._committed = committed</pre></div></div>

        </li>


        <li id="section-116">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>Reset ping tracking information. Leader behavior is different from
other members. We clear out all ping information for ping who are not
our immediate constituents. This will keep us from hoarding stale
ping records. When everyone performs this cleaning, we can then trust
ourselves to return all ping information we’ve gathered to anyone
that pings us, knowing that it is all flowing from minority members
to the leader. We do not have to version the records, timestamp them,
etc.</p>
<p>If we didn’t clear them out, then a stale record for a citizen can be
held onto by a majority member. If the minority member that pings the
citizen is no longer downstream from the majority member, that stale
record will not get updated, but it will be reported to the leader.</p>
<p>We keep ping information if we are the leader, since it all flows
back to the leader. All leader information will soon be updated. Not
resetting the leader during normal operation makes adjustments to
citizenship go faster.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.constituency.length == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">this</span>._minimum.reduced = entry.promise
    }</pre></div></div>

        </li>


        <li id="section-117">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>Notify our constituents of a new update.</p>

            </div>

        </li>


        <li id="section-118">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>TODO This is my we give the leader a zero constituency. Why did we change
it to point to the remainder of the majority?</p>

            </div>

        </li>


        <li id="section-119">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>TODO Recall that we’re not going to continue to ping our constituents
when it comes time to noodle a Paxos waffle, so we’ll ping, but not
update the constituency. TODO This is old and getting goofy.</p>

            </div>

        </li>


        <li id="section-120">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>We count on our writer to set the final synchronize when we are the
leader of a government that is not a dictatorship.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.id != <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>] || <span class="hljs-keyword">this</span>.government.majority.length == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, id; (id = <span class="hljs-keyword">this</span>.constituency[i]) != <span class="hljs-literal">null</span>; i++) {
            <span class="hljs-keyword">this</span>.scheduler.schedule(now, id, { <span class="hljs-attr">method</span>: <span class="hljs-string">'synchronize'</span>, <span class="hljs-attr">to</span>: [ id ], <span class="hljs-attr">collapsible</span>: <span class="hljs-literal">false</span> })
        }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.id == <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>]) {
        <span class="hljs-keyword">this</span>.scheduler.schedule(now, <span class="hljs-keyword">this</span>.id, {
            <span class="hljs-attr">method</span>: <span class="hljs-string">'synchronize'</span>,
            <span class="hljs-attr">to</span>: <span class="hljs-keyword">this</span>.government.majority,
            <span class="hljs-attr">collapsible</span>: <span class="hljs-literal">true</span>
        })
    }
}

Paxos.prototype.inspect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">id</span>: <span class="hljs-keyword">this</span>.id,
        <span class="hljs-attr">writer</span>: <span class="hljs-keyword">this</span>._writer.inspect(),
        <span class="hljs-attr">recorder</span>: <span class="hljs-keyword">this</span>._recorder.inspect(),
        <span class="hljs-attr">head</span>: <span class="hljs-keyword">this</span>.log.head.body
    }
}

<span class="hljs-built_in">module</span>.exports = Paxos</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
