<!DOCTYPE html>

<html>
<head>
  <title>paxos.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>

      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">


                <a class="source" href="acceptor.js.html">
                  acceptor.js
                </a>


                <a class="source" href="assembly.js.html">
                  assembly.js
                </a>


                <a class="source" href="completion.js.html">
                  completion.js
                </a>


                <a class="source" href="legislator.js.html">
                  legislator.js
                </a>


                <a class="source" href="log.js.html">
                  log.js
                </a>


                <a class="source" href="paxos.js.html">
                  paxos.js
                </a>


                <a class="source" href="pinger.js.html">
                  pinger.js
                </a>


                <a class="source" href="proposer.js.html">
                  proposer.js
                </a>


                <a class="source" href="recorder.js.html">
                  recorder.js
                </a>


                <a class="source" href="redux.js.html">
                  redux.js
                </a>


                <a class="source" href="relay.js.html">
                  relay.js
                </a>


                <a class="source" href="replay.js.html">
                  replay.js
                </a>


                <a class="source" href="shape.js.html">
                  shape.js
                </a>


                <a class="source" href="shaper.js.html">
                  shaper.js
                </a>


                <a class="source" href="writer.js.html">
                  writer.js
                </a>

            </div>
          </div>
        </li>
      </ul>

    <ul class="sections">

          <li id="title">
              <div class="annotation">
                  <h1>paxos.js</h1>
              </div>
          </li>



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Common utilities.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>)

</pre></div></div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Return the first not null-like value.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> coalesce = <span class="hljs-built_in">require</span>(<span class="hljs-string">'extant'</span>)

</pre></div></div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Ever increasing serial value with no maximum value.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Monotonic = <span class="hljs-built_in">require</span>(<span class="hljs-string">'monotonic'</span>).asString

</pre></div></div>

        </li>


        <li id="section-4">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>A timer with named, cancelable events.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Scheduler = <span class="hljs-built_in">require</span>(<span class="hljs-string">'happenstance'</span>).Scheduler

</pre></div></div>

        </li>


        <li id="section-5">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>An evented message queue used for the atomic log.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Procession = <span class="hljs-built_in">require</span>(<span class="hljs-string">'procession'</span>)
<span class="hljs-keyword">var</span> Window = <span class="hljs-built_in">require</span>(<span class="hljs-string">'procession/window'</span>)

</pre></div></div>

        </li>


        <li id="section-6">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>A sorted index into the atomic log. TODO Must it be a tree?</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Indexer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'procession/indexer'</span>)

</pre></div></div>

        </li>


        <li id="section-7">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Logging conduit.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'prolific.logger'</span>).createLogger(<span class="hljs-string">'paxos'</span>)

</pre></div></div>

        </li>


        <li id="section-8">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>The participants in the Paxos strategy.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Assembly = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./assembly'</span>)
<span class="hljs-keyword">var</span> Proposer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./proposer'</span>)
<span class="hljs-keyword">var</span> Acceptor = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./acceptor'</span>)

</pre></div></div>

        </li>


        <li id="section-9">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>The participants in the two-phase commit strategy.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Shaper = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./shaper'</span>)
<span class="hljs-keyword">var</span> Writer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./writer'</span>)
<span class="hljs-keyword">var</span> Recorder = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./recorder'</span>)

<span class="hljs-keyword">var</span> Pinger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./pinger'</span>)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Paxos</span> (<span class="hljs-params">now, republic, id, options</span>) </span>{
</pre></div></div>

        </li>


        <li id="section-10">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Uniquely identify ourselves relative to the other participants.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.id = <span class="hljs-built_in">String</span>(id)

</pre></div></div>

        </li>


        <li id="section-11">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Use the create time as a cookie to identify this instance of this id.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.cookie = now

</pre></div></div>

        </li>


        <li id="section-12">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>A republic identifies a paritcular instance of the Paxos algorithm.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.republic = republic

</pre></div></div>

        </li>


        <li id="section-13">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Maybe start out naturalized if no futher updates necessary.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.naturalized = !! options.naturalized

    <span class="hljs-keyword">this</span>.parliamentSize = coalesce(options.parliamentSize, <span class="hljs-number">5</span>)

</pre></div></div>

        </li>


        <li id="section-14">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>The atomic log is a linked list. When head of the list is advanced the
entries in the list go out of scope and can be collected by the garbage
collector. We advance the head of the list when we are certain that all
participants have received a copy of the entry and added it to their
logs. Note that outstanding user iterators prevent this garbage
collection, but when we advance the head the entries are dead to us.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.log = <span class="hljs-keyword">new</span> Window
    <span class="hljs-keyword">this</span>.log.addListener(<span class="hljs-keyword">this</span>.indexer = <span class="hljs-keyword">new</span> Indexer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">left, right</span>) </span>{
        assert(left &amp;&amp; right)
        assert(left.body &amp;&amp; right.body)
        <span class="hljs-keyword">return</span> Monotonic.compare(left.body.promise, right.body.promise)
    }))

</pre></div></div>

        </li>


        <li id="section-15">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Implements a calendar for events that we can check during runtime or
ignore during debugging playback.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.scheduler = <span class="hljs-keyword">new</span> Scheduler

</pre></div></div>

        </li>


        <li id="section-16">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>This is the right data structure for the job. It is an array of proposals
that can have at most one proposals for a new government, where that
proposal is unshifted into the array and all the subsequent proposals
have their promises remapped to the new government.</p>
<p>Returning to this, I felt that it made no sense, just push the new
governent onto the end of the array, but then you’re moving toward scan
the array for an existing government to assert that it is not there, or
else queuing governments based on either the current government, or the
last future government pushed onto the proposal array.</p>
<p>Although it’s not multi-dimensional, I see this structure in my mind as
somehow ether dash shapped, an array of just proposals, or L shaped an
array of proposals with a new government unshifted.</p>
<p>Sometimes there’s a scout leader, and sometimes there’s not.</p>
<p>But, the array is the correct structure. It makes the remapping easy.</p>
<p>Governments jumping the gun is the right way to go, and here’s how we
prioritize them, by constantly unshifting only the next one onto the
array.</p>
<p>This means that there is a queue of awaiting governments. It is, however,
implicit. We will review our current government when we create a new one,
and when a ping changes the reachable state of a constituent. Recall that
a new government is formed to immigrate or exile a citizen.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.proposals = []
    <span class="hljs-keyword">this</span>.immigrating = []

    <span class="hljs-keyword">this</span>.government = {
        <span class="hljs-attr">promise</span>: <span class="hljs-string">'0/0'</span>,
        <span class="hljs-attr">minority</span>: [],
        <span class="hljs-attr">majority</span>: [],
        <span class="hljs-attr">constituents</span>: [],
        <span class="hljs-attr">properties</span>: {},
        <span class="hljs-attr">immigrated</span>: { <span class="hljs-attr">id</span>: {}, <span class="hljs-attr">promise</span>: {} }
    }

    <span class="hljs-keyword">this</span>._promised = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">this</span>.promise = <span class="hljs-string">'0/0'</span>

</pre></div></div>

        </li>


        <li id="section-17">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>TODO Randomly adjust election retry by a percentage. Randomly half or
randomly half as much again.</p>

            </div>

            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">this</span>.ping = coalesce(options.ping, <span class="hljs-number">1000</span>)
    <span class="hljs-keyword">this</span>.timeout = coalesce(options.timeout, <span class="hljs-number">5000</span>)

    <span class="hljs-keyword">this</span>.constituency = []
    <span class="hljs-keyword">this</span>.citizens = []

    <span class="hljs-keyword">this</span>.minimum = <span class="hljs-string">'0/0'</span>

    <span class="hljs-keyword">this</span>.outbox = <span class="hljs-keyword">new</span> Procession

    <span class="hljs-keyword">this</span>._pinger = <span class="hljs-keyword">new</span> Pinger(<span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>.timeout)

</pre></div></div>

        </li>


        <li id="section-18">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>   this.least = this.log.shifter()</p>

            </div>

        </li>


        <li id="section-19">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>TODO So, does it matter if the user nevers sees <code>0/0</code>?</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.log.push({
        <span class="hljs-attr">module</span>: <span class="hljs-string">'paxos'</span>,
        <span class="hljs-attr">promise</span>: <span class="hljs-string">'0/0'</span>,
        <span class="hljs-attr">body</span>: <span class="hljs-keyword">this</span>.government
    })

    <span class="hljs-keyword">this</span>._writer = <span class="hljs-keyword">new</span> Writer(<span class="hljs-keyword">this</span>, <span class="hljs-string">'1/0'</span>)
    <span class="hljs-keyword">this</span>._recorder = <span class="hljs-keyword">new</span> Recorder(<span class="hljs-keyword">this</span>, <span class="hljs-string">'1/0'</span>)
    <span class="hljs-keyword">this</span>._shaper = <span class="hljs-keyword">new</span> Shaper(<span class="hljs-keyword">this</span>.parliamentSize, <span class="hljs-keyword">this</span>.government)
}

</pre></div></div>

        </li>


        <li id="section-20">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>We are only ever supposed to call <code>newGovernment</code> when we are not in the
process of forming a new government. There is only ever supposed to be one in
process or in the queue. You’ll notice that we call <code>newGovernment</code> during
bootstrap, during consensus selection and during collapse. Many decisions
about the new goverment are based on the current government, so we can’t have
them queued up, unless we want to also maintain the latest version of the
government we hope to have someday, which offends my pragmatic sensibilities.</p>

            </div>

        </li>


        <li id="section-21">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype.newGovernment = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, quorum, government, promise</span>) </span>{
    <span class="hljs-keyword">this</span>._shaper.decided = <span class="hljs-literal">true</span>
    assert(!government.constituents)
    promise = Monotonic.increment(<span class="hljs-keyword">this</span>.promise, <span class="hljs-number">0</span>)
    government.constituents = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.government.properties).sort().filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">citizen</span>) </span>{
        <span class="hljs-keyword">return</span> !~government.majority.indexOf(citizen)
            &amp;&amp; !~government.minority.indexOf(citizen)
    })
    <span class="hljs-keyword">var</span> remapped = government.promise = promise, map = {}
    <span class="hljs-keyword">this</span>.proposals = <span class="hljs-keyword">this</span>.proposals.splice(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.proposals.length).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">proposal</span>) </span>{
        proposal.was = proposal.promise
        proposal.route = government.majority
        proposal.promise = remapped = Monotonic.increment(remapped, <span class="hljs-number">1</span>)
        map[proposal.was] = proposal.promise
        <span class="hljs-keyword">return</span> proposal
    })
    <span class="hljs-keyword">this</span>._promised = remapped
    <span class="hljs-keyword">var</span> properties = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>.government.properties))
    <span class="hljs-keyword">var</span> immigrated = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>.government.immigrated))
</pre></div></div>

        </li>


        <li id="section-22">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>TODO I’d rather have a more intelligent structure.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (government.immigrate) {
        <span class="hljs-keyword">var</span> immigrate = government.immigrate
        properties[immigrate.id] = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(government.immigrate.properties))
        government.constituents.push(immigrate.id)
        immigrated.promise[immigrate.id] = promise
        immigrated.id[promise] = immigrate.id
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (government.exile) {
        <span class="hljs-keyword">var</span> exile = government.exile
        exile.promise = immigrated.promise[exile.id]
        exile.properties = properties[exile.id]
        <span class="hljs-keyword">delete</span> immigrated.promise[exile.id]
        <span class="hljs-keyword">delete</span> immigrated.id[exile.promise]
        <span class="hljs-keyword">delete</span> properties[exile.id]
        government.constituents.splice(government.constituents.indexOf(exile.id), <span class="hljs-number">1</span>)
    }
</pre></div></div>

        </li>


        <li id="section-23">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>TODO Null map to indicate collapse or change in leadership. Wait, change in
leader is only ever collapse? Ergo…</p>

            </div>

            <div class="content"><div class='highlight'><pre>    government.map = <span class="hljs-keyword">this</span>._writer.collapsed ? <span class="hljs-literal">null</span> : map
    government.immigrated = immigrated
    government.properties = properties
    assert(<span class="hljs-keyword">this</span>.proposals.length == <span class="hljs-number">0</span> || !Monotonic.isBoundary(<span class="hljs-keyword">this</span>.proposals[<span class="hljs-number">0</span>].promise, <span class="hljs-number">0</span>))
    <span class="hljs-keyword">this</span>._writer.unshift({ <span class="hljs-attr">promise</span>: promise, <span class="hljs-attr">quorum</span>: quorum, <span class="hljs-attr">body</span>: government })
    <span class="hljs-keyword">this</span>._writer.nudge()
}

</pre></div></div>

        </li>


        <li id="section-24">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Find a round of paxos in the log based on the given promise.</p>
<p>Not loving how deeply nested these conditions and keys are, but I understand
why it is that way, and it would be a full wrapper of <code>bintrees</code> to fix it.</p>

            </div>

        </li>


        <li id="section-25">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype._findRound = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sought</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.indexer.tree.find({ <span class="hljs-attr">body</span>: { <span class="hljs-attr">promise</span>: sought } })
}

Paxos.prototype._stuffSynchronize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pings, sync, count</span>) </span>{
    <span class="hljs-keyword">var</span> ping = pings[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, I = pings.length; i &lt; I; i++) {
        assert(ping.committed != <span class="hljs-literal">null</span> &amp;&amp; pings[i].committed != <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">if</span> (Monotonic.compare(pings[i].committed, ping.committed) &lt; <span class="hljs-number">0</span>) {
            ping = pings[i]
        }
        assert(ping.committed != <span class="hljs-string">'0/0'</span>)
    }
    <span class="hljs-keyword">var</span> iterator
    <span class="hljs-keyword">if</span> (ping.committed == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ping.committed == <span class="hljs-string">'0/0'</span>) {
        iterator = <span class="hljs-keyword">this</span>.log.trailer.node.next
        <span class="hljs-keyword">for</span> (;;) {
</pre></div></div>

        </li>


        <li id="section-26">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>TODO This will abend if the naturalization falls off the end end of the log.
You need to check for gaps and missing naturalizations and then timeout the
constituents that will never be connected.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (iterator == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
            }
</pre></div></div>

        </li>


        <li id="section-27">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>assert(round, ‘cannot find immigration’)</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (Monotonic.isBoundary(iterator.body.promise, <span class="hljs-number">0</span>)) {
                <span class="hljs-keyword">var</span> immigrate = iterator.body.body.immigrate
                <span class="hljs-keyword">if</span> (immigrate &amp;&amp; immigrate.id == ping.id) {
                    <span class="hljs-keyword">break</span>
                }
            }
            iterator = iterator.next
        }
    } <span class="hljs-keyword">else</span> {
</pre></div></div>

        </li>


        <li id="section-28">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>If our minimum promise is greater than the most decided promise for
the contituent then our ping record for the constituent is out of
date.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (Monotonic.compare(ping.committed, <span class="hljs-keyword">this</span>.minimum) &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }

</pre></div></div>

        </li>


        <li id="section-29">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>TODO Got a read property of null here.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        iterator = <span class="hljs-keyword">this</span>._findRound(ping.committed).next
    }

    <span class="hljs-keyword">while</span> (--count &amp;&amp; iterator != <span class="hljs-literal">null</span>) {
        sync.commits.push({
            <span class="hljs-attr">promise</span>: iterator.body.promise,
            <span class="hljs-attr">body</span>: iterator.body.body,
            <span class="hljs-attr">previous</span>: <span class="hljs-literal">null</span>
        })
        iterator = iterator.next
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}

Paxos.prototype._prepare = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, request, sync</span>) </span>{
    <span class="hljs-keyword">this</span>._recorder = <span class="hljs-keyword">new</span> Acceptor(<span class="hljs-keyword">this</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._recorder.request(now, request, sync)
}

Paxos.prototype._collapse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now</span>) </span>{
    <span class="hljs-keyword">this</span>.scheduler.clear()

    <span class="hljs-keyword">this</span>._writer = <span class="hljs-keyword">new</span> Proposer(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.promise)
    <span class="hljs-keyword">this</span>._pinger = <span class="hljs-keyword">new</span> Pinger(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> Assembly(<span class="hljs-keyword">this</span>.government, <span class="hljs-keyword">this</span>.id))
    <span class="hljs-keyword">this</span>._pinger.update(now, <span class="hljs-keyword">this</span>.id, {
        <span class="hljs-attr">naturalized</span>: <span class="hljs-keyword">this</span>.naturalized,
        <span class="hljs-attr">committed</span>: <span class="hljs-keyword">this</span>.log.head.body.promise
    })

</pre></div></div>

        </li>


        <li id="section-30">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>TODO This is fine. Realize that immigration is a special type of
somethign that is built on top of proposals. Ah, or maybe assembly is the
shaper and a shaper creates the next shaper. Thus, shaper is the
abstraction that is above writer/recorder. Also, Assembly could be called
something else, gatherer or collector or roll call or sergent at arms.</p>

            </div>

            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">this</span>.immigrating.length = <span class="hljs-number">0</span>

    <span class="hljs-keyword">this</span>.government.majority.concat(<span class="hljs-keyword">this</span>.government.minority)
        .filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
            <span class="hljs-keyword">return</span> id != <span class="hljs-keyword">this</span>.id
        }.bind(<span class="hljs-keyword">this</span>)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
            <span class="hljs-keyword">this</span>.scheduler.schedule(now, id, {
                <span class="hljs-attr">module</span>: <span class="hljs-string">'paxos'</span>,
                <span class="hljs-attr">method</span>: <span class="hljs-string">'ping'</span>,
                <span class="hljs-attr">body</span>: { <span class="hljs-attr">method</span>: <span class="hljs-string">'collpase'</span> }
            })
        }, <span class="hljs-keyword">this</span>)
}

</pre></div></div>

        </li>


        <li id="section-31">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Determine the minimum log entry promise.</p>
<p>You might feel a need to guard this so that only the leader runs it, but it
works of anyone runs it. If they have a ping for every citizen, they’ll
calculate a minimum less than or equal to the minimum calculated by the
actual leader. If not they do not have a ping record for every citizen,
they’ll continue to use their current minimum.</p>
<p>Would rather this was on object that was updated only when we got ping
information back.</p>

            </div>

        </li>


        <li id="section-32">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype._minimize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> minimum = <span class="hljs-keyword">this</span>.getPing(<span class="hljs-keyword">this</span>.id).committed
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, citizen; (citizen = <span class="hljs-keyword">this</span>.citizens[i]) != <span class="hljs-literal">null</span>; i++) {
        <span class="hljs-keyword">var</span> ping = <span class="hljs-keyword">this</span>.pings[citizen]
        <span class="hljs-keyword">if</span> (ping == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span>
        }
        <span class="hljs-keyword">if</span> (Monotonic.compare(ping.committed, minimum) &lt; <span class="hljs-number">0</span>) {
            minimum = ping.comitted
        }
    }
    <span class="hljs-keyword">this</span>.minimum = minimum
}

Paxos.prototype.event = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">envelope</span>) </span>{
    <span class="hljs-keyword">if</span> (envelope.module != <span class="hljs-string">'happenstance'</span> || envelope.method != <span class="hljs-string">'event'</span>) {
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">var</span> now = envelope.now
    <span class="hljs-keyword">switch</span> (envelope.body.method) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'ping'</span>:
        <span class="hljs-keyword">this</span>._send({
            <span class="hljs-attr">method</span>: <span class="hljs-string">'synchronize'</span>,
            <span class="hljs-attr">to</span>: [ envelope.key ],
            <span class="hljs-attr">sync</span>: <span class="hljs-literal">null</span>
        })
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'keepAlive'</span>:
        <span class="hljs-keyword">this</span>._send({
            <span class="hljs-attr">method</span>: <span class="hljs-string">'synchronize'</span>,
            <span class="hljs-attr">to</span>: <span class="hljs-keyword">this</span>.government.majority,
            <span class="hljs-attr">sync</span>: <span class="hljs-literal">null</span>
        })
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'collapse'</span>:
        <span class="hljs-keyword">this</span>._collapse(envelope.now)
        <span class="hljs-keyword">break</span>
    }
}

Paxos.prototype._send = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request</span>) </span>{
    request.sync = {
        <span class="hljs-attr">from</span>: <span class="hljs-keyword">this</span>.id,
        <span class="hljs-attr">minimum</span>: <span class="hljs-keyword">this</span>.minimum,
        <span class="hljs-attr">committed</span>: <span class="hljs-keyword">this</span>.log.head.body.promise,
        <span class="hljs-attr">cookie</span>: <span class="hljs-keyword">this</span>.cookie,
        <span class="hljs-attr">commits</span>: []
    }
    <span class="hljs-keyword">var</span> pings = []
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, to; (to = request.to[i]) != <span class="hljs-literal">null</span>; i++) {
        pings.push(<span class="hljs-keyword">this</span>._pinger.getPing(to))
    }
    <span class="hljs-keyword">this</span>._stuffSynchronize(pings, request.sync, <span class="hljs-number">20</span>)
    <span class="hljs-keyword">this</span>.outbox.push(request)
}

Paxos.prototype.bootstrap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, properties</span>) </span>{
</pre></div></div>

        </li>


        <li id="section-33">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Update current state as if we’re already leader.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.naturalize()

    <span class="hljs-keyword">var</span> government = {
        <span class="hljs-attr">promise</span>: <span class="hljs-string">'1/0'</span>,
        <span class="hljs-attr">majority</span>: [ <span class="hljs-keyword">this</span>.id ],
        <span class="hljs-attr">minority</span>: [],
        <span class="hljs-attr">constituents</span>: [],
        <span class="hljs-attr">map</span>: {},
        <span class="hljs-attr">immigrate</span>: { <span class="hljs-attr">id</span>: <span class="hljs-string">'0'</span>, <span class="hljs-attr">properties</span>: properties, <span class="hljs-attr">cookie</span>: <span class="hljs-number">0</span> },
        <span class="hljs-attr">properties</span>: {},
        <span class="hljs-attr">immigrated</span>: { <span class="hljs-attr">promise</span>: {}, <span class="hljs-attr">id</span>: {} }
    }

    <span class="hljs-keyword">this</span>.immigrating.push({ <span class="hljs-attr">id</span>: <span class="hljs-keyword">this</span>.id })

    government.properties[<span class="hljs-keyword">this</span>.id] = properties
    government.immigrated.promise[<span class="hljs-keyword">this</span>.id] = <span class="hljs-string">'1/0'</span>
    government.immigrated.id[<span class="hljs-string">'1/0'</span>] = <span class="hljs-keyword">this</span>.id

    <span class="hljs-keyword">this</span>._promised = <span class="hljs-string">'1/0'</span>

    <span class="hljs-keyword">this</span>._shaper.immigrate({ <span class="hljs-attr">id</span>: <span class="hljs-keyword">this</span>.id, <span class="hljs-attr">cookie</span>: <span class="hljs-number">0</span> })

    <span class="hljs-keyword">this</span>._enact(now, { <span class="hljs-attr">promise</span>: <span class="hljs-string">'1/0'</span>, <span class="hljs-attr">body</span>: government })
}

Paxos.prototype.naturalize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.naturalized = <span class="hljs-literal">true</span>
}

</pre></div></div>

        </li>


        <li id="section-34">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>TODO Is all this checking necessary? Is it necessary to return the island id
and leader? This imagines that the client is going to do the retry, but in
reality we often have the cluster performt the retry. The client needs to
talk to a server that can be discovered, it can’t use the Paxos algorithm for
address resolution. From the suggested logic, it will only have a single
address, and maybe be told of an actual leader. What happens when that
address is lost? Don’t see where returning <code>republic</code> and leader helps at
all. It is enough to say you failed, backoff and try again. The network layer
can perform checks to see if the recepient is the leader and hop to the
actual leader if it isn’t, reject if it is but collapsed.</p>
<p>Once you’ve externalized this in kibitz, remove it, or pare it down.</p>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype._enqueuable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">republic</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._writer.collapsed || <span class="hljs-keyword">this</span>.republic != republic) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">enqueued</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">republic</span>: <span class="hljs-keyword">this</span>.republic,
            <span class="hljs-attr">leader</span>: <span class="hljs-literal">null</span>
        }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>] != <span class="hljs-keyword">this</span>.id) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">enqueued</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">republic</span>: <span class="hljs-keyword">this</span>.republic,
            <span class="hljs-attr">leader</span>: <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>]
        }
    }
}

</pre></div></div>

        </li>


        <li id="section-35">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Note that a client will have to treat a network failure on submission as a
failure requiring boundary detection.</p>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, republic, message</span>) </span>{

    <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">this</span>._enqueuable(republic)
    <span class="hljs-keyword">if</span> (response == <span class="hljs-literal">null</span>) {
</pre></div></div>

        </li>


        <li id="section-36">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>TODO Bombs out the current working promise.
TODO Note that we used to snapshot the majority here as the route but
that can change. Note that the last issued promise is not driven by
government enactment, it is incremented as we greate new promises and
governments.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">this</span>._promised = Monotonic.increment(<span class="hljs-keyword">this</span>._promised, <span class="hljs-number">1</span>)
        <span class="hljs-keyword">this</span>._writer.push({
            <span class="hljs-attr">promise</span>: promise,
            <span class="hljs-attr">route</span>: <span class="hljs-literal">null</span>,
</pre></div></div>

        </li>


        <li id="section-37">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>route: this.government.majority,</p>

            </div>

            <div class="content"><div class='highlight'><pre>            body: message
        })
        <span class="hljs-keyword">this</span>._nudge(now)

        response = {
            <span class="hljs-attr">enqueued</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">leader</span>: <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>],
            <span class="hljs-attr">promise</span>: promise
        }
    }

    <span class="hljs-keyword">return</span> response
}

</pre></div></div>

        </li>


        <li id="section-38">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>TODO This is a note. I’d like to find a place to journal this. I’m continuing
to take measures to allow for the reuse of ids. It still feels right to me
that a display of government or of the census would be displayed using values
meaningful to our dear user; Kubernetes HOSTNAMES, AWS instance names, IP
address, and not something that is garunteed unique like a UUID, because such
things are indistinguishable to the human observer.</p>
<p>Yet, here I am again contending with an issue that would be so simple if ids
where required to be unique. When a citizen that is a constituent dies and
restarts with the same id it will be pinged by someone in government, it will
report that it’s empty, and its representative will look for it’s immigration
record. There’s a race now. Is the new instance going to immigrate before its
pinged? Or is the representative going to search for an immigration record
and not find one, which causes us to abend at the moment?</p>
<p>When we get a sync before immigration, it will not see a cookie or not see
the right cookie and fail the sync. These syncs fail, time passes, the time
out comes and the record is cleared. That takes care of the race when the
sync beats the immigration record, but what if the immigration record beats
the representative?</p>
<p>In that case their will be a new government with the same represenative with
the same consitutent, but now there will be an immigration record. The
consituent will be naturalized. It will never have been exiled.</p>
<p>This is a problem. Implementations are going to need to know that they’ve
restarted. A participant should be exiled before it can immigrate again.</p>
<p>Obviously, much easier if the ids are unique. Whole new id means not
ambiguity. The new id immigrates, the old id exiles. (Unique ids are easy
enough to foist upon our dear user implementation wise. Most implementations
reset a process or at least an object, and that new instance can have a new
id generated from POSIX time or UUID.)</p>
<p>However, we do have an atomic log at our disposal, so every time I think that
I should give up and go with unique ids, something comes along to make it
simple. I was actually musing about how the client, if they really wanted
pretty ids, they could just check and wait for the old id to exile, since it
only needs to be unique in the set of current ids. Then, duh, I can do that
same check on immigration and reject the immigration if the id already exists
in the census.</p>
<p>That’s what you’re looking at here.</p>
<p>Now that that is done, though, is there a race condition where the
immigration is currently being proposed? The property wouldn’t be removed
until the proposal was enacted.</p>

            </div>

        </li>


        <li id="section-39">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype.immigrate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, republic, id, cookie, properties</span>) </span>{
    <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">this</span>._enqueuable(republic)
    <span class="hljs-keyword">if</span> (response == <span class="hljs-literal">null</span>) {
</pre></div></div>

        </li>


        <li id="section-40">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Do not allow the user to initiate the immigration of an id that
already exists. This will happen if a denizen crash restarts and
tries to rejoin before Paxos can determine that the denizen is no
longer viable. The immigrating denizen should enter a back off and
retry loop in order to wait for exile.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (id <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.government.properties) {
            response = {
                <span class="hljs-attr">enqueued</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">republic</span>: <span class="hljs-keyword">this</span>.republic,
                <span class="hljs-attr">leader</span>: <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>]
            }
        } <span class="hljs-keyword">else</span> {
            response = { <span class="hljs-attr">enqueued</span>: <span class="hljs-literal">true</span> }

            <span class="hljs-keyword">var</span> shape = <span class="hljs-keyword">this</span>._shaper.immigrate({ id, <span class="hljs-attr">properties</span>: properties, <span class="hljs-attr">cookie</span>: cookie })
            <span class="hljs-keyword">if</span> (shape != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">this</span>.newGovernment(now, shape.quorum, shape.government)
            }
        }
    }
    <span class="hljs-keyword">return</span> response
}

</pre></div></div>

        </li>


        <li id="section-41">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>TODO Note that minimum only ever goes up so a delayed minimum is not going to
ever be invalid. We don’t want to run it in case it rejects our start.</p>

            </div>

        </li>


        <li id="section-42">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype.request = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, request</span>) </span>{
</pre></div></div>

        </li>


        <li id="section-43">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>TODO Reject if it is the wrong republic.
TODO Reject if it a message from an exile, wrong id and cookie.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> sync = {
        <span class="hljs-attr">from</span>: <span class="hljs-keyword">this</span>.id,
        <span class="hljs-attr">naturalized</span>: <span class="hljs-keyword">this</span>.naturalized,
        <span class="hljs-attr">minimum</span>: <span class="hljs-keyword">this</span>.minimum,
        <span class="hljs-attr">committed</span>: <span class="hljs-keyword">this</span>.log.head.body.promise,
        <span class="hljs-attr">cookie</span>: <span class="hljs-keyword">this</span>.cookie,
        <span class="hljs-attr">commits</span>: []
    }

    <span class="hljs-keyword">if</span> (Monotonic.compare(request.sync.committed, sync.committed) &lt; <span class="hljs-number">0</span>) {
</pre></div></div>

        </li>


        <li id="section-44">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>We are ahead of the bozo trying to update us, so update him back.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._stuffSynchronize(now, sync, sync, <span class="hljs-number">20</span>)
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">method</span>: <span class="hljs-string">'reject'</span>, <span class="hljs-attr">promise</span>: sync.committed, <span class="hljs-attr">sync</span>: sync }
    }

</pre></div></div>

        </li>


        <li id="section-45">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Sync.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, commit; (commit = request.sync.commits[i]) != <span class="hljs-literal">null</span>; i++) {
        <span class="hljs-keyword">this</span>._commit(now, commit)
    }

</pre></div></div>

        </li>


        <li id="section-46">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>We don’t want to advance the minimum if we have no items yet.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.log.head.body.body.promise != <span class="hljs-string">'0/0'</span>) {
        <span class="hljs-keyword">while</span> (Monotonic.compare(<span class="hljs-keyword">this</span>.log.trailer.peek().promise, request.sync.minimum) &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">this</span>.log.trailer.shift()
        }
        <span class="hljs-keyword">if</span> (Monotonic.compare(<span class="hljs-keyword">this</span>.minimum, request.sync.minimum) &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">this</span>.minimum = request.sync.minimum
        }
    }

    <span class="hljs-keyword">if</span> (request.method == <span class="hljs-string">'synchronize'</span>) {
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">sync</span>: sync }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._recorder.request(now, request, sync)
    }
}

Paxos.prototype.response = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, request, responses</span>) </span>{
</pre></div></div>

        </li>


        <li id="section-47">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>If anyone we tried to update is ahead of us, we learn from them.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, I = request.to.length; i &lt; I; i++) {
        <span class="hljs-keyword">var</span> response = responses[request.to[i]]
        <span class="hljs-keyword">if</span> (response == <span class="hljs-literal">null</span>) {
            responses[request.to[i]] = { <span class="hljs-attr">sync</span>: { <span class="hljs-attr">committed</span>: <span class="hljs-string">'0/0'</span> } }
            <span class="hljs-keyword">this</span>._pinger.update(now, request.to[i], <span class="hljs-literal">null</span>)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>._pinger.update(now, request.to[i], response.sync)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>, commit; (commit = response.sync.commits[j]) != <span class="hljs-literal">null</span>; i++) {
                <span class="hljs-keyword">this</span>._commit(commit)
            }
        }
    }
</pre></div></div>

        </li>


        <li id="section-48">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>TODO Probably run every time, probably always fails.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (request.method == <span class="hljs-string">'synchronize'</span>) {
        <span class="hljs-keyword">var</span> delay = <span class="hljs-keyword">this</span>.log.head.body.promise == responses[request.to[<span class="hljs-number">0</span>]].sync.committed
                  ? now + <span class="hljs-keyword">this</span>.ping
                  : now
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.constituency.length == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">this</span>.scheduler.schedule(delay, request.to[<span class="hljs-number">0</span>], {
                <span class="hljs-attr">module</span>: <span class="hljs-string">'paxos'</span>,
                <span class="hljs-attr">method</span>: <span class="hljs-string">'keepAlive'</span>,
                <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span>
            })
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.scheduler.schedule(delay, request.to[<span class="hljs-number">0</span>], {
                <span class="hljs-attr">module</span>: <span class="hljs-string">'paxos'</span>,
                <span class="hljs-attr">method</span>: <span class="hljs-string">'ping'</span>,
                <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span>
            })
        }
        <span class="hljs-keyword">return</span>
    }
</pre></div></div>

        </li>


        <li id="section-49">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>TODO If the recepient is at ‘0/0’ and we attempted to synchronize it,
then we must not have had the right cookie, let’s mark it as unreachable
for exile.</p>

            </div>

        </li>


        <li id="section-50">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Only handle a response if it was issued by our current writer/proposer.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (request.version[<span class="hljs-number">0</span>] == <span class="hljs-keyword">this</span>._writer.version[<span class="hljs-number">0</span>] &amp;&amp; request.version[<span class="hljs-number">1</span>] == <span class="hljs-keyword">this</span>._writer.version[<span class="hljs-number">1</span>]) {
        <span class="hljs-keyword">var</span> promise = <span class="hljs-string">'0/0'</span>, failed = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> id <span class="hljs-keyword">in</span> responses) {
            <span class="hljs-keyword">if</span> (responses[id] == <span class="hljs-literal">null</span>) {
                failed = <span class="hljs-literal">true</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (Monotonic.compare(promise, responses[id].promise) &lt; <span class="hljs-number">0</span>) {
                    promise = responses[id].promise
                }
                <span class="hljs-keyword">if</span> (responses[id].method == <span class="hljs-string">'reject'</span>) {
                    failed = <span class="hljs-literal">true</span>
                }
            }
        }
        <span class="hljs-keyword">this</span>._writer.response(now, request, responses, failed ? promise : <span class="hljs-literal">null</span>)
    }
}

Paxos.prototype._commit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, entry</span>) </span>{
    <span class="hljs-keyword">var</span> entries = []
    <span class="hljs-keyword">while</span> (entry) {
        entries.push({ <span class="hljs-attr">promise</span>: entry.promise, <span class="hljs-attr">body</span>: entry.body })
        entry = entry.previous
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, entry; (entry = entries[i]) != <span class="hljs-literal">null</span>; i++) {
        <span class="hljs-keyword">this</span>._enact(now, entry)
    }
}

Paxos.prototype._enact = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, message</span>) </span>{
    message = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(message))
    logger.info(<span class="hljs-string">'_receiveEnact'</span>, { <span class="hljs-attr">now</span>: now, <span class="hljs-attr">$message</span>: message })

    <span class="hljs-keyword">var</span> max = <span class="hljs-keyword">this</span>.log.head.body

</pre></div></div>

        </li>


        <li id="section-51">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>We already have this entry. The value is invariant, so let’s assert that
the given value matches the one we have.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (Monotonic.compare(max.promise, message.promise) &gt;= <span class="hljs-number">0</span>) {
</pre></div></div>

        </li>


        <li id="section-52">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>TODO Difficult to see how we could get here and not have a copy of
the message in our log. If we received a delayed sync message that
has commits that precede our minimum, seems like it would have been
rejected at entry, the committed versions would be off.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        assert(Monotonic.compare(<span class="hljs-keyword">this</span>.minimum, message.promise) &lt;= <span class="hljs-number">0</span>)
</pre></div></div>

        </li>


        <li id="section-53">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>TODO Deep equal comparison of JSON value.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span>
    }

    <span class="hljs-keyword">var</span> valid = max.promise != <span class="hljs-string">'0/0'</span>

    <span class="hljs-keyword">if</span> (!valid) {
</pre></div></div>

        </li>


        <li id="section-54">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>assert(this.log.size == 1)</p>

            </div>

            <div class="content"><div class='highlight'><pre>        valid = Monotonic.isBoundary(message.promise, <span class="hljs-number">0</span>)
        valid = valid &amp;&amp; <span class="hljs-keyword">this</span>.log.trailer.peek().promise == <span class="hljs-string">'0/0'</span>
        valid = valid &amp;&amp; message.body.immigrate
        valid = valid &amp;&amp; message.body.immigrate.id == <span class="hljs-keyword">this</span>.id
        valid = valid &amp;&amp; message.body.immigrate.cookie == <span class="hljs-keyword">this</span>.cookie
    }

    <span class="hljs-keyword">if</span> (!valid) {
</pre></div></div>

        </li>


        <li id="section-55">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>TODO We can see failure when the returned max is still 0/0.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        pulse.failed = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">return</span>
    }

    <span class="hljs-keyword">var</span> isGovernment = Monotonic.isBoundary(message.promise, <span class="hljs-number">0</span>)
    logger.info(<span class="hljs-string">'enact'</span>, {
        <span class="hljs-attr">outOfOrder</span>: !(isGovernment || Monotonic.increment(max.promise, <span class="hljs-number">1</span>) == message.promise),
        <span class="hljs-attr">isGovernment</span>: isGovernment,
        <span class="hljs-attr">previous</span>: max.promise,
        <span class="hljs-attr">next</span>: message.promise
    })

</pre></div></div>

        </li>


        <li id="section-56">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>TODO How crufy are these log entries? What else is lying around in them?</p>

            </div>

            <div class="content"><div class='highlight'><pre>    max.next = message
    message.previous = max.promise
</pre></div></div>

        </li>


        <li id="section-57">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Forever bombing out our latest promise.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.promise = message.promise

    <span class="hljs-keyword">if</span> (isGovernment) {
        <span class="hljs-keyword">this</span>._enactGovernment(now, message)
    }

    <span class="hljs-keyword">var</span> pinger = <span class="hljs-keyword">new</span> Pinger(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>._shaper = <span class="hljs-keyword">this</span>._shaper.createShaper(<span class="hljs-keyword">this</span>))

    pinger.ingest(now, <span class="hljs-keyword">this</span>._pinger, <span class="hljs-keyword">this</span>.constituency)

    <span class="hljs-keyword">this</span>._pinger = pinger

    <span class="hljs-keyword">this</span>._pinger.update(now, <span class="hljs-keyword">this</span>.id, { <span class="hljs-attr">naturalized</span>: <span class="hljs-keyword">this</span>.naturalized, <span class="hljs-attr">committed</span>: message.promise })

    <span class="hljs-keyword">this</span>.log.push({
        <span class="hljs-attr">module</span>: <span class="hljs-string">'paxos'</span>,
        <span class="hljs-attr">method</span>: isGovernment ? <span class="hljs-string">'government'</span> : <span class="hljs-string">'entry'</span>,
        <span class="hljs-attr">promise</span>: message.promise,
        <span class="hljs-attr">previous</span>: max.promise,
        <span class="hljs-attr">body</span>: message.body
    })

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, id; (id = <span class="hljs-keyword">this</span>.constituency[i]) != <span class="hljs-literal">null</span>; i++) {
        <span class="hljs-keyword">this</span>.scheduler.schedule(now, id, { <span class="hljs-attr">module</span>: <span class="hljs-string">'paxos'</span>, <span class="hljs-attr">method</span>: <span class="hljs-string">'ping'</span>, <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span> })
    }
}

</pre></div></div>

        </li>


        <li id="section-58">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Majority updates minority. Minority updates constituents. If there is
no minority, then the majority updates constituents.</p>

            </div>

        </li>


        <li id="section-59">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Paxos.prototype._determineConstituency = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.constituency = []
    <span class="hljs-keyword">var</span> parliament = <span class="hljs-keyword">this</span>.government.majority.concat(<span class="hljs-keyword">this</span>.government.minority)
    <span class="hljs-keyword">if</span> (parliament.length == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.id == <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>]) {
            <span class="hljs-keyword">this</span>.constituency = <span class="hljs-keyword">this</span>.government.constituents.slice()
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>.government.majority.slice(<span class="hljs-number">1</span>).indexOf(<span class="hljs-keyword">this</span>.id)
        <span class="hljs-keyword">if</span> (~index) {
            <span class="hljs-keyword">var</span> length = <span class="hljs-keyword">this</span>.government.majority.length - <span class="hljs-number">1</span>
            <span class="hljs-keyword">var</span> population = <span class="hljs-keyword">this</span>.government.minority.length
                           ? <span class="hljs-keyword">this</span>.government.minority
                           : <span class="hljs-keyword">this</span>.government.constituents
            <span class="hljs-keyword">this</span>.constituency = population.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, i</span>) </span>{
                <span class="hljs-keyword">return</span> i % length == index
            })
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (~(index = <span class="hljs-keyword">this</span>.government.minority.indexOf(<span class="hljs-keyword">this</span>.id))) {
            <span class="hljs-keyword">var</span> length = <span class="hljs-keyword">this</span>.government.minority.length
            <span class="hljs-keyword">this</span>.constituency = <span class="hljs-keyword">this</span>.government.constituents.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, i</span>) </span>{
                <span class="hljs-keyword">return</span> i % length == index
            })
        }
    }
}

Paxos.prototype._enactGovernment = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">now, round</span>) </span>{
    <span class="hljs-keyword">this</span>.scheduler.clear()

    assert(Monotonic.compare(<span class="hljs-keyword">this</span>.government.promise, round.promise) &lt; <span class="hljs-number">0</span>, <span class="hljs-string">'governments out of order'</span>)

    <span class="hljs-keyword">this</span>.government = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(round.body))

    <span class="hljs-keyword">this</span>._writer = <span class="hljs-keyword">this</span>._writer.createWriter(round.promise)
    <span class="hljs-keyword">this</span>._recorder = <span class="hljs-keyword">this</span>._recorder.createRecorder()
    <span class="hljs-keyword">this</span>._shaper = <span class="hljs-keyword">this</span>._shaper.createShaper(<span class="hljs-keyword">this</span>)

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.exile) {
</pre></div></div>

        </li>


        <li id="section-60">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>TODO Remove! Fall back to a peek at exile.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.pings[<span class="hljs-keyword">this</span>.government.exile.id]
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.immigrate &amp;&amp; <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>] == <span class="hljs-keyword">this</span>.id) {
        <span class="hljs-keyword">this</span>._shaper.immigrated(<span class="hljs-keyword">this</span>.government.immigrate.id)
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.id != <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>]) {
        <span class="hljs-keyword">this</span>.proposals.length = <span class="hljs-number">0</span>
    }

</pre></div></div>

        </li>


        <li id="section-61">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>TODO Decide on whether this is calculated here or as needed.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.parliament = <span class="hljs-keyword">this</span>.government.majority.concat(<span class="hljs-keyword">this</span>.government.minority)

    <span class="hljs-keyword">this</span>._determineConstituency()
    assert(!<span class="hljs-keyword">this</span>.constituency.length || <span class="hljs-keyword">this</span>.constituency[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span>)
    <span class="hljs-keyword">this</span>.scheduler.clear()
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>] == <span class="hljs-keyword">this</span>.id &amp;&amp; <span class="hljs-keyword">this</span>.government.majority.length != <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">this</span>.scheduler.schedule(now + <span class="hljs-keyword">this</span>.ping, <span class="hljs-keyword">this</span>.id, {
            <span class="hljs-attr">module</span>: <span class="hljs-string">'paxos'</span>,
            <span class="hljs-attr">method</span>: <span class="hljs-string">'keepAlive'</span>,
            <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span>
        })
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (~<span class="hljs-keyword">this</span>.government.majority.slice(<span class="hljs-number">1</span>).indexOf(<span class="hljs-keyword">this</span>.id)) {
        <span class="hljs-keyword">this</span>.scheduler.schedule(now + <span class="hljs-keyword">this</span>.timeout, <span class="hljs-keyword">this</span>.id, {
            <span class="hljs-attr">module</span>: <span class="hljs-string">'paxos'</span>,
            <span class="hljs-attr">method</span>: <span class="hljs-string">'collapse'</span>,
            <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span>
        })
    }

</pre></div></div>

        </li>


        <li id="section-62">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>Reset ping tracking information. Leader behavior is different from other
members. We clear out all ping information for ping who are not our
immediate constituents. This will keep us from hoarding stale ping
records. When everyone performs this cleaning, we can then trust
ourselves to return all ping information we’ve gathered to anyone that
pings us, knowing that it is all flowing from minority members to the
leader. We do not have to version the records, timestamp them, etc.</p>
<p>If we didn’t clear them out, then a stale record for a citizen can be
held onto by a majority member. If the minority member that pings the
citizen is no longer downstream from the majority member, that stale
record will not get updated, but it will be reported to the leader.</p>
<p>We keep ping information if we are the leader, since it all flows back to
the leader. All leader information will soon be updated. Not resetting
the leader during normal operation makes adjustments to citizenship go
faster.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.citizens = <span class="hljs-keyword">this</span>.government.majority
                        .concat(<span class="hljs-keyword">this</span>.government.minority)
                        .concat(<span class="hljs-keyword">this</span>.government.constituents)
}

<span class="hljs-built_in">module</span>.exports = Paxos

</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
